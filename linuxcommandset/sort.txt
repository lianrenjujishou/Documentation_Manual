sort命令的作用是:对文本行进行排序
-t 设置字段的分隔符,分隔符和-t之间可以无空格(默认以空白作为分隔符,在sort命令中不仅有行的概念还有字段的概念,行是对整个文本来说的一个基本单位,而字段是相对于行的基本单位)
-ka.b[modifier],c.d[modifier] 这里的参数是-k，abcd都是子参数,子参数我就不加[]进行说明了,我用具体的情况说一下,-k用来设置比较的字符串的范围,其中a和c表示第几个字段,b和d表示相应字段的第几个字符,
例如-k3.2,5,3表示在文本中进行比较排序的时候行与行之间的比较都是从第3个字段第2个字符开始,到第5个字段第3个字段结束,其它的不管.如果只有一个开始字段和结束字段,没有相应的字符字符,则表示从开始字段的第一个字符开始到结束字段的最后一个字符结束,-k和子参数之间可以无空格. 
  *.当使用-k参数时,一般是和-b或-t进行联用,使用-b则在比较的时候可以忽略前导空白,否则前导空白会作为第一个字符;同样虽然字段分隔符默认为空白, 但如果你不显式的指定-t使用空白字符,则-k在取字段时也会将相应字段的前导空白作为第一个字符.因此大多数情况而言, 只要有-k出现,一般都会伴随着-t或-b.而使用-t参数指定\t作为分隔符时,不能用-t '\t',此时\t不会被解释为水平制表符, 而要用-t $'\t'
-r 对排序取反,这个好理解,比如正常排出来一到五行是12345,则sort -r后一到五行的数据就为54321了.
-d 这个参数好像是取字典的首字母,官方给的解释是只对空白,数字,大小写字母进行排序,但是似乎在比较时空白都会被当作0,但是空格又比tab靠前(用passwd试了一下怎么感觉忽略空白了!!!???)
-f 忽略字母的大小写,实际上不是忽略也忽略不了,只是在比较前都将所有的小写字母都转变为大写字母后进行比较,这不就间接的说明了忽略大小写了嘛,因为也没有大小写之分了比较的时候都是大写的
  *.因为环境变量的原因, 经测试在debian上sort的行为没问题,默认不忽略字母大小写,加上-f后就忽略了; 但在archlinux上测试默认情况下就忽略字母大小写,也就是说默认情况下, -f参数没用,并且想不忽略大小写也不行, 这种情况下,排序时需要指定一下环境变量,指定后archlinux默认就不忽略大小写了,cat data | LC_COLLATE=C sort [-f]
-n 其实本文中的数字都是字符串格式的,-n参数意思是按照数字的大小进行排序,但是排序之前是有一个预处理过程的,即将文本转为数字,这个转换考虑的已经很全了,比如数字前面有空白的会将空白去掉,数字前面有加减号的也能识别为正负数,数字后面有点的,点也会被忽略,总而言之,各种含有正常数字形式的字符串都可以转为相应的数字格式,然后进行数值的比较
-b 忽略开头的空白,即空格,tab等,如果忽略开头的空白,则空白后的第一个字符为首字符
-i 仅仅比较可打印字符,即忽略不可打印的字符
-M 按照英文月份进行排序,'unknown'<'JAN'<...<'DEC',此处这十二个月简写全写都可以
-o 将排序结果输出到文件,可以直接输出到排序文件而不会将被排序文件清空,这一点比重定向符号>要强.
-u 去重
-c 看看文本内容是否已排序,可以和相应的选项合用,看看是否文本已按相应的选项排序
    *. [root@yang tmp]# LC_COLLATE=C sort -c data  //因为archlinux默认环境问题,此时要加上LC_COLLATE=C来使默认不忽略字母大小写
       sort: data:2: disorder: A 2	Henry	80000	2
-h 有一些单位不是数字,如2kg,1G等人类可读的单位,也可以进行排序
-z 用0字节作为行的结尾,而不用换行符
-T 用该选项指定临时目录,多个选项要指定多个目录
-m 说白了就是把多个文件给拼接起来,不存在排序这步.所以有些情况下我们要先得到排序后的文件, 然后再将这些文件进行拼接
-S 设置主内存缓冲区的大小,默认是1024K 单位可以是b,M,G,T,P,E,Z,Y.
有的系统可以指定--parallel=N 来并发处理(多核情况下),用的时候需要看一下系统支不支持这个选项
*.这个命令还需要多磨练,如-S设置的那个缓冲区指的是最大可以处理多长的行？还是指一次可以加载多少文本到内存？再就是-m到底合并后排不排序?
*.提高排序速度:使用parallel参数?,将-T到一个快速缓冲区(是否可以利用大内存虚拟出一个硬盘作为-T?),设置大的-S?
