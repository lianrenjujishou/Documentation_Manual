SED(1)           User Commands           SED(1)

NAME
sed - 过滤和改变(transform转换)文本的流编辑器

DESCRIPTION Sed是一个流编辑器.
一个流编辑器被用于执行对一个输入流的基本的文本转换(该输入流可以是一个文件也可以是由管道传过来的).i当在某些情况下和允许脚本编辑的编辑器(如ed)更相似,Sed works by making only one pass over the input(s),结果是更有效率.但是过滤通过管道传过来的文本的能力最能区分Sed和其它类型的编辑器.

【ok】-n, --quiet, --silent
抑制模式空间的自动打印

【ok】-e script, --expression=script
添加脚本到被执行的命令后面(暂且认为这个被执行的命令就是sed)

【ok】-f script-file, --file=script-file
添加script-file的内容到被执行的命令

--follow-symlinks
当处理合适的话遵循符号链接(pass)

-i[SUFFIX], --in-place[=SUFFIX]
在合适的位置编辑文件(pass)

-l N, --line-length=N
为l命令指定期望的line-wrap(换行)长度

--posix
禁用所有的GNU扩展

-r, --regexp-extended
在脚本中使用扩展的正则表达式

-s, --separate
将文件看作是分开的(这块通过练习补充是分开的什么?)而不是一个单独的连续的长流

-u, --unbuffered
从输入文件加载最少数量的数据并且经常清除输出buffers(缓存还是缓冲现在还区分不了这两个名词)

-z, --null-data
将NUL作为行的结尾符(官翻为通过NUL来分隔行)

--help
显示该篇帮助并退出

--version
显示sed的版本信息并退出

如果没有-e,
--expression,-f或是--file选项给出,则第一个非选项参数被解释为sed脚本.剩下的所有参数被看作是输入的文件名;如果没有指定输入文件,则从标准输入读取.

GNU版本的sed主页:<http://www.gnu.org/software/sed/>.GNU软件的常规帮助页:<http://www.gnu.org/gethelp/>.发现bug可以发e-mail到<bug-sed@gnu.org>.请确保要将'sed'写在主题部分.

COMMAND SYNOPSIS
这仅仅是一个sed的简要大纲,该篇大纲的目的仅仅是给那些已经了解sed的人作一个提醒;如果你想要看完整的描述的话,你必须要查看例如texinfo这样的文档.

Zero-address ``commands''(这是为啥呀左边用``右边用''?)
:label
b和t命令的标签(标记)

#comment
#后面的为注释以下一个新行标志着结束(或者是-e script片断的末尾)

}
一个{}块的结尾括号

Zero- 或者One- address commands
【ok】= 打印行号且行号独占一行位于行的上方

【ok】a\
text   或c\与text在一行,貌似是gun版的sed支持写在一行的形式
-----------------------------------------
追加text让每一个嵌入的新行被前置通过一个反斜杠(应该是这个意思have sth
done:让sth被do)(作为一个GNU扩展,这个命令(可以)接受两个地址(的形式).

将a后面的文本放入队列,然后在当前循环结束后或当下一行被读取时,将队列中的内容打印到屏幕上,说白了就是,先将a后面的内容给存起来,不和模式空间掺乎,然后模式空间里的内容处理完并打印到屏幕上之后,将存起来的内容再输出到刚刚处理完的内容的后面(输出时a\中的\是被忽略而不被输出的.)

a后面的文本如果含有转义序列的话也是会被处理的,因此如果你想要在a后面的内容里含有\的话你应该写作\\.

作为一个GNU扩展,如果在a与\之间含有除了空白以外的其它字符,则该字符也会被算到被追加的内容里面.后面说a\123这种形式书写简单,貌似是因为在非gnu的sed中a\与123需要分两行写,现在其它的模式也没时间考虑,暂时先这样记吧.这个扩展同样适用于i与c命令.

另外再说一句,对于有a\命令的处理过程应该是:先将a\后面要追加的内容存到一个地方,然后从文本流中读取一行,执行相应的命令,将处理完成之后的文本流输出然后加上\n(加\n是因为how
the sed works中的原理讲的,如果原文本中的\n则读入模式空间时先将\n给删掉,处理完之后再给加上),然后再将存储的a后的内容输出,然后再加上一个\n(这个\n应该肯定是有的))
-----------------------------------------

【ok】i\
text     或c\与text在一行,貌似是gun版的sed支持写在一行的形式,并且要记得c与\之间是可以有内容的,详细的看a\text里的解释,对于这块的内容a,c,i是相同的
-----------------------------------------
作为一个GNU扩展,这个命令(可以)接受两个地址(的形式).

立刻将i\后面的文本输出(i后面的\会忽略不输出),另外还要注意a中说的i与c同样适用的那段,就是说如果i与\之间还有除空白之外的字符,则那些字符也会被计在插入的字符串中

再多说一句,i立即输出应该也是和模式空间没一毛钱关系,即不是先进模式空间再被输出的;而且i输出后应该也会立即在它的后面加上一个\n,这样当模式空间的行内容输出时才会和i处于两行
-----------------------------------------


test 插入text让每一个嵌入的新行被新置通过一个反斜杠

q [exit-code]
不再处理输入立刻退出sed,除非如果auto-print(自动打印)没有禁用,则当前人间会被打印.退出代码参数是一个GNU扩展.

Q [exit-code]
不再处理输入立刻退出sed.这是一个GNU扩展.

r filename
从filename读取要追加的文本

R filename
从filename读取要追加的一行.命令的每一次调用都从file中读取一行.这是一个GNU扩展.

Commands which accept address ranges
{ 开始一个命令块(以}结尾)

b label label的分支;如果label被忽略,分支(或说转移)到脚本的末尾

【ok】c\
text
或c\与text在一行,貌似是gun版的sed支持写在一行的形式,并且要记得c与\之间是可以有内容的,详细的看a\text里的解释,对于这块的内容a,c,i是相同的
-----------------------------------------
用text替换被选择的行,让每一个内嵌的新行通过反斜杠被前置.(删除匹配上地址或是地址范围的行,并且输出c\后面的内容(c后面的\被忽略不输出),替换掉上一行(或者如果不指定地址的话,替换到每一行,因为每一行都要被读取呀),这个命令执行完后会开始一个新的循环,因为模式空间里的内容在c命令执行完之后就会删除了.
多说一句,大概的流程是先将文本读入模式空间,然后删除模式空间中的文本,再执行c命令将c\后的内容输出,然后加上\n,最后c命令执行完后看到模式空间里没东西了,就开始新的一轮,读内容>删内容>执行c命令...(因为sed的原理是从文本中读一行,然后复制一份,将复制的这份放入模式空间,然后再执行的操作,所以c命令应该也是先读入模式空间再将模式空间内容删除,然后再将c后的内容输出的,但是这样就不如啥也不处理了,直接在指定的地址或地址范围输出c后的内容,反正无论你对读入模式空间的内容咋折腾最后也会被删除而不会输出的))
-----------------------------------------

【ok】d 删除模式空间.开始下一个循环

【ok】D 如果模式空间没有新行,则开始一个普通的新的循环就好像d命令被发出.否则,删除模式空间的文本一直到第一个新行,并且用这个新的模式空间(指的刚刚删到第一个新行的那部分空间)重新开始循环,不读取一个新行的输入.

【ok】h H 拷贝/追加模式空间到驻留空间(hold space)

【ok】g G 拷贝/追加驻留空间(hold space)到模式空间

l 在一个``可视化的清楚的''表格中列出当前行

l width
在一个``可视化的清楚的''表格中列出当前行,在width字符处打断.这是一个GNU扩展.

【ok】n N
-----------------------------------------
读/追加输入的下一行到模式空间.(n:如果自动打印没有被禁用,则打印模式空间内容,然后,regardless,删除当前模式空间的内容并将下一行读入模式空间.如果现在已经位于最后一行了则sed命令会直接退出,而不再执行任何其它的命令.N:添加一个新行到模式空间,这里的新行指的是新行符号\n,然后将下一行追加到模式空间刚刚添加的\n后面.如果已经到达末尾,官翻说的是如果已经没有行可以追加了,则N后面的其它命令将不会再处理而是直接退出sed)
-----------------------------------------

【ok】p 打印当前的模式空间

【ok】P 打印当前的模式空间 直到第一个嵌入的新行

s/regexp/replacement/
尝试在模式空间中匹配regexp.如果成功,用replacement替换掉匹配的部分.replacement可以包含特殊字符&来参考被匹配上的模式空间部分,并且特殊的输入\1到\9来指代regexp中匹配上的子表达式.

t label
如果一个s///已经做了成功的替换,因为上次的(last注意这里是翻译为最后的还是翻译为上次的)输入行被读取并且由于上次的t或T命令,会跳转到label;如果label被忽略,则跳转到脚本的末尾.这是一个GNU的扩展.

T label
如果没有s///替换成功则由于上次的输入行被读取和由于上次的t或T命令,然后跳转到label;如果label被忽略,跳转到脚本的末尾.这是一个GNU扩展

w filename 将当前的模式空间写入到filename

W filename 将当前模式空间的第一行写入到filename.这是一个GNU扩展.

x 交换驻留空间和模式空间的内容

【ok】y/SOURCE-CHARS/DEST-CHARS/
-----------------------------------------
Transliterate(网上翻译为'直译','换字')在source中出现的模式空间到dest中相应的字符(默认情况下y命令中分隔SOURCES-CHARS与DEST-CHARS的是三个正斜杠/,这三个正斜杠可以被统一的替换掉,所谓统一,指的是如果要替换掉的话必须用三个相同的字符去替换,如ys111s222s,yxaaaxaaax这种;那么什么时候会不用默认的呢,比如我要将/替换成a,如果写成y///a/就会出错,而y:/:a:这样程序也认得,我们看得也一目了然;另外说一句,any这个单词的意思不仅有'任何的'意思,还有'所有的'的意思.

用DEST-CHARS中的相应位置的字符去替换掉SOURCE-CHARS相应位置出现的字符,这就要保证两边的字符一样多才好.

字符/ \ \n都可以出现在SOURCE-CHARS或DEST-CHARS中,如果不替换默认的///的情况下,需要对这三个字符用\进行转义才好,即替换/:y/\//x/;替换\:y/\\/x/;替换\n:y/\n/x/.如果不用默认的///改用其它的分隔符则不用转义直接写即可,如替换/:y~/~x~;替换\:y~\~x~;替换\n:y~\n~x~.最后一句需要说的上面也提到过了,就是SOURCE-CHARS与DEST-CHARS中的字符除去转义字符外数量是相等的)

有de前缀的单词一般表示:"离开","脱离","分开",'解去"
------------------------------------------

Addresses
使用Sed命令时可以不限定它的作用范围,在这种情况下会将该命令作用于所有行;如果给出了地址,则Sed命令仅仅作用于被匹配上的行(由这可以看出这个范围可以是正则表达式);如果给出了两个范围则Sed命令的作用域是从第一个范围开始到第二个范围结束的这一段。注意地址范围的三件事情:语法是addr1,addr2(两个地址由逗号分隔);addr1匹配上的行会一直被接受,即使addr2选择的行在addr1前面;如果addr2是一个正则表达式,则它不会被测试是否该行也被addr1匹配上了.

在地址后(或地址范围后)和命令之间可以插入一个!,那表示如果地址或地址范围没有匹配上则执行Sed命令.

下面所列出的地址类型都是支持的:

number 只匹配指定的行number(行号在文件中逐渐增加=which increments cumulatively
across files,除非在命令行上指定-s选项).

first~step 匹配以first开始的每setp行.例如,``sed -n
1~2p''会打印输入文件流中的所有奇数行,地址2~5则是以第2行开始,然后每5行一匹配.first可以是0;在这种情况下,sed操作好像匹配的行等于step(first为0的情况下也就是说假设现在有10行吧,sed
-n 0~2p则会将2,4,6,8,10行打印出来).(这是一个扩展) 	

$ 匹配最后一行(last line)

/regexp/ 匹配上正则regexp的行

\cregexpc 匹配上正则regexp的行.c可以是任何字符

GNU版本的sed还支持一些特殊的2个地址的格式:

0,addr2
以"被匹配上的第一个地址"开始,直到addr2被匹配上.这有点类似于1,addr2,除了addr2匹配上了输入流的第一行,则0,addr2格式是这个范围的结尾,1,addr2是这个范围的开始.最后一句是只有addr2是表达式才可以这么用,如果addr2只是一个数则会提示'非法使用地址0'
***.关于0，addr2官翻说的模模糊糊,我的理解就是首先addr2必须是一个正则才可以使用以0开头的格式,其次就是比如说在第5行匹配上了addr2则范围就是第一行到第五行,如果是在第一行匹配上了那就只有第一行.

addr1,+N 匹配addr1及它下面的N行

addr1,~N 匹配addr1及addr1下面的N-1行

REGULAR EXPRESSIONS
POXIX BREs应该被支持,但是由于性能问题也不是完全支持.\n序列在正则里面匹配newline符,\a,\t及其它序列类似.

**.refer to可否翻译为指代
更详细的日后可参看info sed



练习中自己遇到的问题:
1.看下面文本(所在文件sedtest):
-------------------------------------------------
Consult Section 3.1 in the Owner and Operator
Guide for a dscription of the tape drives
available on your system.

Look in the Owner and Operator Guide shipped with your system.

Two manuals are provided including the Owner and
Operator Guide and the User Guide.

The Owner and Operator Guide is shipped with your system.
-------------------------------------------------
**要明白sed是会处理所有的文本流然后将它们输出,也就是说无论你用的是啥命令最后都会将处理后的文本流输出到屏幕,而且打印时是一行一行的打印,就是说先读第一行处理完成后将第一行打印到屏幕然后再将第二行读到模式空间处理输出到屏幕再读第三行,处理,输出,第四行,...**
上面这句话就解释了sed /Look/p sedtest为什么不是只打印第5行而是打印所有的行了

2.有文本:
yang qiang zhao
yan qiang min zhao
yan min
当我输入sed -e /qiang/N -e s/zhao\nyan/1/g后输出为
yang qiang 1 qiang min zhao
yan min
这就说明>>下一次再读入的行是第三行而不是第二行(刚被追加的行)了,就是说N命令后追加到模式空间的行已经结束了本次循环

3.多行模式空间是N命令创立的,所以P和D起作用的前提是N已经事先出现了

4.理解P命令,有如下文本(所在文件sedtest):
yang qiang zhao
yan qiang min zhao
yan min
给定命令为:sed -e '/qiang/N' -e 's/zhao\nyan/zhao1\nyan1/g' -e 'P' sedtest
输出为:
yang qiang zhao1   这一行是由'P'命令输出的模式空间第一个\n之前的内容
----------------------------
yang qiang zhao1   这两行是sed在处理完之后都会将模式空间中的内容输出得到的
yan 1 qiang min zhao
----------------------------
yan min   这是由'P' 命令得到的
-----------------------------
yan min   这是由sed处理完后都会将模式空间中的内容输出得到的
**.可以看到qiang min
zhao只出现一次,所以在N命令下达的时候就已经完成了它那行的使命,虽然它是被追加进去的,而不是正式被读入的,但在这里也认为是完成了使命.

5.D的用法:http://lsscto.blog.51cto.com/779396/880770

6.三种模式的处理流程:
  都遵循的一个基本流程是:sed(command[s])p
     单行模式:
     多行模式(N,D,P):D,P的前提是由N先创建多行模式(其实就两行);P是打印第一个\n前面的内容;D是删除第一个\n之前的内容,而D命令的特殊之处是删除第一行后不会执行sed()p所说的最后一个p,而是会回到sed中的第一条命令,从第一条命令开始对模式空间中剩下的一行进行处理,直到不满足执行D的条件后才将模式空间的内容输出(其实只要记住含有D命令的语句中只有D前面的条件不满足时才会输出模式空间的内容并清空模式空间,而一旦D前面的条件满足则会执行两步:第一步是删除第一个\n前面的内容,此时模式空间里就还剩一行了,然后将sed只的所有命令应用在这一行上)
     带保持空间的(h,H,x,g,G):这个只要记住：1.这5个命令是用于在模式空间与保持空间中传递数据用的;2.大小和小写的区别为:小写是改写另一个空间内容,大写将内容追加到另一空间,改写的意思相当于先在另一空间执行d命令,然后再将数据给拷贝过去,即此时另一空间只剩下最新拷贝过去的命令了;而追加好理解,相当于先拷贝本空间的内容然后移到另一个空间将鼠标定位到结尾处并粘贴.3.大写的H,G都会先放上一个\n(即H的话,首先会在保持空间放置一个\n(无论现在保持空间是否有内容)然后将模式空间的内容追加到\n后面,而G的话是先在模式空间后面放置一个\n然后将保持空间的内容放到\n后面),可以简单的将hH和gG理解为'从哪取,往哪放'.4.x就简单了就是交换两个空间的内容



