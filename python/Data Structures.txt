5.数据结构
这章主要是对你前面所学内容的一个深化也会介绍一些新的内容.
5.1.更多关于列表的知识
列表这种数据类型有好多的方法可用,下面是所有列表可用的方法:
    list.append(x)  #在列表的尾部追加一个条目.等价于a[len(a):] = [x],记住这种等价的方法
    list.entend(L)  #将列表L中的所有元素都追加到列表中.等价于a[len(a):] = L
    *.apped和extend的就是x是作为一个整体追加到列表的最后,而L是将给定的序列打散成单个字符追加到列表的最后
    list.insert(i,x)	#在给定位置i处插入一个条目x. a.insert(0, x)是在列表头部插入一条数据x,a.insert(len(a), x)相当于在列表尾部插入一条数据,等价于a.append(x)
    list.remove(x)  #移除列表中第一个值为x的元素.如果列表中没有值x则会出错
    list.pop([i])   #将索引指定的元素从列表中移除,并将移除的元素打印到屏幕上.如果没有指定索引,则移除并返回列表最后一个元素.(另外说明一下,这里的[]表明其中的i是可选的不是必须的,以后还会有好多的[]出现在语法中,到时碰到了你要明白,这表示被[]括起来的部分在应用时是可选的,而不是指[]是表达式必须的一部分)
    list.clear()    #从列表中移除所有的元素.等价于del a[:]
    list.index(x)   #返回列表中第一个值为x的索引号.如果列表中没有元素x,会发生错误
    list.count(x)   #返回值x在列表中出现的次数
    list.sort(key=None,reverse=False)
#对列表中的元素进行排序,暂时可以将列表中的每一个元素想象为文本中的一行,三个元素的列表就相当于三行文本(到目前为止见到list.sort()的用法就是在上一章的lambda的用法中,pairs
= [(1, 'one'), (2, 'two'), (3, 'three'), (4, 'four')] >>>
pairs.sort(key=lambda pair: pair[1]))然后按照linux中的sort命令的d选项去理解就好,python内嵌的对列表和字典排序方法还有一个sorted(),等这篇文章译完后回过头来再看它的详解
    list.reverse()  #对列表中的元素取反,取反后list中元素的顺序就已经变了,换句话说就是list的reverse()方法会直接改变列表
    list.copy()	    #返回一个列表的附本.等价于Equivalent to a[:]   前面遇到过在循环中直接改变列表里值的时候,这个复本不是指列表的别名,而是又在内存中开辟了一块空间,即列表list与list.copy()在内存中的指向是不同的
下面看一下关于列表方法的使用实例:
>>> a = [66.25, 333, 333, 1, 1234.5]
>>> print(a.count(333), a.count(66.25), a.count(x))
2 1 0
>>> a.insert(2, -1)
>>> a.append(333)
>>> a
[66.25, 333, -1, 333, 1, 1234.5, 333]
>>> a.index(333)
1
>>> a.remove(333)
>>> a
[66.25, -1, 333, 1, 1234.5, 333]
>>> a.reverse()
>>> a
[333, 1234.5, 1, 333, -1, 66.25]
>>> a.sort()
>>> a
[-1, 1, 66.25, 333, 333, 1234.5]
>>> a.pop()
1234.5
>>>a
[-1, 1, 66.25, 333, 333]    
你可能注意到了像列表中的insert(),remove(),sort()方法改变列表后并看不到返回值,其实它们操作完是有返回值的,只不过返回的是None,被忽略了.这是Python中所有可变的数据结构的设计原理.

5.1.1.将列表用作栈(解释一下堆栈,其实就是存的时候是从顶部存,取的时候也从顶部取,我们理解时可以想成出和进都是从一头,并且只能取最外边的一个,不能取中间的)
列表提供的那些方法使得很容易的将列表当作栈使用,最后一个放入的元素总是第一个被检索("last-in","first-out"即后进先出).为了将一个元素加到栈顶可以用append()方法.为了检索一个数据从栈顶用没有明确索引的pop()方法.举例:
>>> stack = [3, 4, 5]
>>> stack.append(6)
>>> stack.append(7)
>>> stack
[3, 4, 5, 6, 7]
>>> stack.pop()
7
>>> stack
[3, 4, 5, 6]
>>> stack.pop()
6
>>> stack.pop()
5
>>> stack
[3, 4]

5.1.2.将列表用作队列
我们也可以将列表用作队列,也就是说先添加的元素先被检索出去("first-in",
"first-out"即先进先出);然而列表固有的方法对"先进先出"的这一想法不是很高效.当我们向列表尾部追加或是从列表尾部弹出数据时速度很快,但是当我们向列表头部插入或是从列表头部弹出一个数据速度是很慢的(因为对列表头部进入插入或是弹出的时候,列表出的其它元素都会发生移动,比如都向前移一位或是都向后移一位).
所以为了实现一个高效的队列,我们可以使用collections模块的deque类,它设计的初衷就是为了快速的从列表的两端都能高效的追加和弹出,举例:
>>> from collctions import deque
>>> queue = deque(["Eric", "John", "Michael"])	#将deque()返回的对象赋给queue,下面是queue来调用对象的方法实现一些操作
>>> queue.append("Terry")
>>> queue.append("Graham")
>>> queue.popleft()
'Eric'
>>> queue.popleft()
'John'
>>> queue
deque(['Michael', 'Terry', 'Graham'])
对于上面这个例子来说,比如有一个列表[1,2,3,4,5],它逻辑上会认为这个列表是从左到右一个一个加进去的,即1先被插入列表,最后是5被插入列表,collections模块的deque类提供的append()方法向列表的尾部添加数据,popleft()方法从左边弹出数据,就有了队列的"先进先出"的意思了

5.1.3.列表推导(或叫列表解析)
列表推导为我们创建列表提供了一种简单的创建列表的方法.通常新的列表元素是一些操作的结果被应用到另一个序列或是迭代器所得到的结果,或者是创建一个满足特定条件的某些元素的子序列
举例来说,假如我们想要创建一个平方数的列表,正常情况下是这样:
>>> sequares = []
>>> for x in range(10):
... squares.append(x**2)
...
>>> squares
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
但是需要注意的是,我们在创建列表的时候引入了一个x变量,这个变量即使在squares这个列表创建完毕后也还是存在的.我们可以用没有任何负作用的方式来创建这个列表:
squares = list(map(lambda x: x**2, range(10)))
或者与之等价的方式:
squares = [x**2 for x in range(10)]
最后一种方法更简捷可读性更高.
一个列表推导是由三部分组成,第一部分为列表标志性的方括号[],第二部分是方括号中的表达式,最三部分是表达式后面的for从句;而且在第三部分的for从句后面还可以有0到多个for从句或是if从句.而列表推导的结果会产生一个新的列表,这个列表便是由[]中的表达式及一系列的for及if从句得出的.下面的例子中,如果x和y值不等则会将元素结合起来:
>>> [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]
[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4),(3, 1) , (3, 4) ]   #从结果来猜测一下该推导的处理流程
上面这个推导还可以用下面的方法来实现:
>>> combs = []
>>> for x in [1, 2, 3]:
...	for y in [3, 1, 4]:
...	     x != y:
...		combs.append((x, y))
...
>>> combs
[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]	
需要注意的是上面这两个例子中的for和if的顺序应该是相同的,否则会出现'赋值之前就被调用之类的错误'
如果表达式是一个元组,必须要用圆括号将其括起来(例如上上个例子中提到的(x, y)):
>>> vec = [-4, -2, 0, 2, 4]
>>> [x*2 for x in vec]	#用列表vec重新建一个元素平方的表
[-8, -4, 0, 4, 8]
>>>[x for x in vec if x >=0]	#建立的新列表中将负数排除掉
[0, 2, 4]
>>> [abs(x) for x in vec]   #将函数作为表达式
[4, 2, 0, 2, 4]
>>>freshfruit = ['   banana', '    loganberry', 'passion fruit   ']  #将方法用作表达式(python中对方法简单的定义是类中的函数,但是说的也不准确网上有一篇收藏文章给了一个更精确的解释,所以该方法前面必须有类名)
['banana', 'loganberry', 'passion fruit']
>>>[(x, x**2) for x in range(6)]    #创建一个含有两个元素的元组,注意,如果是元组需要用()将元素中的元素括起来
[(0, 0), (1, 1), (2, 4), (3, 9), (4, 16), (5, 25)]
>>> [x, x**2 for x in range(6)]	    #如果元素没有被括号括起来会出错,提示语法错误
    File "<stdin>", line 1, in ?
      [x, x**2 for x in range(6)]
		 ^
SyntaxError: invalid syntax
>>> vec = [[1,2,3], [4,5,6], [7,8,9]]
>>> [num for elem in vec for num in elem]   #去掉内嵌的列表,使多维列表变为一组的
[1, 2, 3, 4, 5, 6, 7, 8, 9]
*.到这插一句,对于列表推导如果理解不是很好的话,可以根据结果将列表推导的式子,试着转成普通的组合语句
列表推导中的表达式也可以很复杂,如表达式中包含函数:
>>> from math import pi
>>> [str(round(pi, i)) for i in range(1, 6)]
['3.1', '3.14', '3.142', '3.1416', '3.14159']
**.回头将单层列表推导及多层嵌入列表推导的原理好好理一下,就是设定空列表,及for和if的一个组合使用
5.1.4.表达式嵌套列表推导
列表推导中的表达式可以是任意的表达式,但然该表达式也可以是一个列表推导.
考虑一下下面的3*4的列表矩阵
>>> matrix = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]
下面这个列表推导很有用,作用就是平时我们常说的 '行列转换' 或叫 '行列转置' 或叫 '行列置换':
>>> [[row[i] for row in matrix] for i in range(4)]
[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
我们将这个内嵌的列表推导先作为一个普通的表达式,故上面的嵌套列表推导可以写作:
>>> transposed = []
>>> for i in range(4):
	transposed.append([row[i] for row in matrix])
>>>transposed  #此时也可以得出结果,但是看着写的还不怎么清晰,内层的还没有解出来
[[1,5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
我们可以将内嵌的表达式也解开:
>>> transposed = []
>>> for i in range(4):
...	transposed_row = []
...	for row in matrix:
...	    transposed_row.append(row[i])
...	transposed.append(transposed_row)
>>> transposed
[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
对于在现实世界中,我们可能更喜欢用内建的东西而不是复杂的语句流,单单对于这个行列转换来说,有一个内建的zip()函数也可以很好的完成这个工作:
>>> list(zip(*matrix))
[(1, 5, 9), (2, 6, 10), (3, 7, 11), (4, 8, 12)]
我们可以看Unpacking Argument Lists来得到更多关于*号的意思,这一章已经看过了,是在第三章,其实就是将散数取成列表的反向即,将列表里的数都取出来,**的意思也是一样就是将字典中的键值对都取出来,详情可翻到上一章看看

5.2. del语句
我们可以通过del语句中给定元素索引号的方式来删除列表中指定索引的元素.它和pop()函数不同的地方是pop()根据列表删除值后会将删除的值打印出来,而del只是单独的删除.del语句的参数也可以为分片,从而一次删除多于一个的数据,如果分片没有首尾值,即del(:),则会清空整个列表(前面我们做过用切片给列表赋空值).例如:
>>>a = [-1, 1, 66.25, 333, 333, 1234.5]
>>> del a[0]
>>> a
[1, 66.25,333, 333, 1234.5]
>>> del a[2:4]
>>> a
[1, 66.25, 1234.5]
>>> del a[:]
>>> a
[]
还可以用del语句来删除整个变量,这个变量不仅指咱们上面操作的列表,其它类型的变量也可以,如字典类型的,字符串类型的:
>>> del a
变量在用del删除后,如果再引用就会发生错误(至少是再次给这个变量赋值前是这样的).后面我们还会看到del的其它用法.

5.3.元组和序列
前面我们已经知道列表和字符串有很多相同的属性,你如索引、切片操作.列表和字符串是序列数据类型的两个例子(可以看Sequence
Type --list, tuple,
range).我们可能看得有些晕,这里说的序列数据类型明明没有字符串,只提到了list,后面就要学到,其实字符串的本质就是元素即tuple,是不可变数据类型.由于Python还在不断的发展,所以可能还会添加更多的序列数据类型.下面讲一下另一个标准的序列数据类型,tuple(元组):
元组是由若干个被逗号分隔的值组成的,例如:
>>> t = 12345, 54321, 'hello!'
>>> t[0]
12345
>>> t
(12345, 54321, 'hello!')
>>> #和列表一样元组也可以内嵌
... u = t, (1, 2, 3, 4, 5)
>>> u
((12345, 54321, 'hello!'), (1, 2, 3, 4, 5))
>>> #元组和列表不同的地方:元组是不可变的
... t[0]= 88888
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment
>>> #虽然说tuple是不可修改的,但是tuple中可以包含可修改的数据类型数据,如列表(也就是说应该对列表中的元素进行修改时也会检查指定元素的数据类型是否为可修改的数据类型)
... v = ([1, 2, 3], [3, 2, 1])
>>> v
([1, 2, 3], [3, 2, 1])
正如你所看到的,在输出时,tuple总是被圆括号包着,以便于可以被解释器正确的解释;在输入元素的元素时,圆括号可加可不加(如定义一个元组变量时),虽然通常情况下圆括号是必须的(如果元素是一个大的表达式的一部分的时候,在输入时必须要用圆括号将元组的元素括起来).给元组中的单个元素赋值是不可能的,但是我们可能创建一个包含有可变对象(如列表)的元组,然后我们可以利用多组索引来对这个元组中的列表对象做赋值操作.
尽管元组看起来和列表差不多,但他们通常被用在不同的情况下,目的也不同.元组是不可变的,通常元组中的元素类型很杂,并且通过解包或索引的方式访问.列表是可变的,通常情况下列表中的元素类型相同,并且是通过遍历列表来访问. (记住不同的类型的特征和常见用法,在实际遇到问题的时候,我们才可能根据我们脑子中的索引来找到具体要用到哪些东西)
在创建0或1个元素的元组时,创建的方法有些特殊,创建空元组的做法是:将一对圆括号赋给元组,如a = (),创建含有一个元素的元组时,需要在元素后面加上一个逗号,如a=('yang',)或a ='yang',如果不加逗号的话,即使是将单个元素放入圆括号内也不行,单个元素在圆括内不加其后面的逗号的话和没有圆括号的效果是一样的,例如:
>>> empty = ()
>>> singleton = 'hello',    #注意要有逗号拖尾
>>> len(empty)
0
>>> len(singleton)
1
>>> singleton
('hello',)
语句 t = 12345, 54321,
'hello!'是一个将多个元素打包成数组的例子,我们反向操作将元组中的数据解包也是可以的:
>>> x, y, z =t     #即相当于x = t[0],y = t[1],z = t[2]
对序列进行解包一般要求左边要有和序列元素个数相同的变量才行,如p = '1234' 在进行解包时左边的变量数也要是4个,如a, b, c, d = p  这样的话a=1 b=2 c=3 d=4,如果解包时我们写成a,b,c = p就会报错,说被解包的元素过多超过3个

5.4. 集合
python中也有集合这种数据类型.set中的元素是没有数据的,最重要的一点是其中的元素不能重复.set的基本用法有测试某个值是否在该set中,或者是用于消除重复的数据.set对象可以支持数学运算,如并集,交集,(两个集合中不同的,即a有b没有或反之),对称差分
花括号或是set()函数可以用来创建集合(set).注意:要创建一个空的set,一定要用set(),而不能用{};因为空的花括号会创建一个空的字典类型,而不是一个集合,字典这种类型我们会在下面讲到.
我们先来看一个关于集合(set)的简要演示:
>>> basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}
>>> print(basket)
{'orange', 'banana', 'pear', 'apple'}
>>> 'orange' in basket
True
>>> 'crabgrass' in basket
False
>>> # 下面说一下两个集合的操作
...
>>> a = set('abracadabra')
>>> b = set('alacazam')
>>> a
{'a', 'r', 'b', 'c', 'd'}
>>>a - b
{'r', 'd', 'b'}
>>> a | b	#并集,将a和b的放到一起再去重就是了
{'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'}
>>> a & b	#a和b共有的
{'a', 'c'}
>>> a ^ b
{'r', 'd', 'b', 'm', 'z', 'l'}	#a和b不共有的,即a中有的但b中没有和b中有的但a中没有
集合同列表一样,也支持集合推导:
>>> a = {x for x in 'abracadabra' if x not in 'abc'}
>>> a
{'r', 'd'}
元组的这个推导转化方式和列表推导是一样的,最大不同就是追加到空集合时用的函数为add()函数,set不支持append(),有关set的函数要看一些

5.5. 字典
另外一种比较有用的python内建的数据类型是dictionary(字典).在其它语言中字典这个类型往往被叫做'联想记忆'或'关联数组'.和序列不同,序列是通过一个给定的数字范围进行索引,而字典则是通过key(键)进行索引,这个key的可以是任何的不可变类型,如字符串或是数字都可以作为key.如果tuples中的元素仅仅包含字符串,数字及元组的话也可以做为key;如果元组中直接或间接的包含有可变的对象则不可被用作键,如列表,因为列表可以通过索引,分片及常用的append()和extend()等方法被修那.
我们最好将字典认为是一种无序的,并且key是唯一的key:value对的集合,可以用一对花括号来创建一个空字典:{}.在花括号中放置一个由逗号作为分隔符的key:value对列表来初始化字典(所谓的程序初始化不就是给一系列的变量赋值嘛,所以这里的初始化说白了就是给字典赋值);字典被输出也是这种方式,即一对花括号中包括着由逗号分隔的N组键值对
字典最主要的操作就是用key来存储value和根据给定的key来提取value.我们也可以用del语句来删除一个键值对.如果你给一个已经存在的键进行赋值,则该键以前的值就会被新值所覆盖.如果想用一个字典中不存在的Key来提取值会报错的.
如果d是一个字典的话,执行list(d.keys())会返回一个由d中所有的key组成的列表,该列表是无序的.如果想要返回一个有序的列表可以用sorted(d.keys())来代替.同样可以用关键字in来判断某个key是某在指定的字典里.
下面给出一个关于字典用法的示例:
>>> tel = {'jack':4098, 'sape':4139}
>>> tel['guido'] = 4127
>>> tel
{'sape':4139, 'guido':4127, 'jack':4098}
>>> tel['jack']
4098
>>> del tel['sape']
>>> tel['irv'] = 4127
>>> tel
{'guido':4127, 'irv':4127, 'jack':4098}
>>> list(tel.keys())
['irv', 'guido', 'jack']
>>> sorted(tel.keys())
['guido', 'irv', 'jack']
>>> 'guido' in tel
True
>>> 'jack' not in tel
False
dic()构造器可以直接从key-value对序列创建字典:
>>> dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])
{'sape': 4139, 'jack': 4098, 'guido': 4127}
另外也可以用字典推导来创建字典,只不过此时表达式为由冒号分隔的key和value两部分组成:
>>> {x: x**2 for x in (2, 4, 6)}
{2: 4, 4: 16, 6: 36}
如果key比较简单的话,我们也可以用关键字参数来指定键值对(其实这里面它的'关键字参数'指的就是由等号分隔的键值对):
>>> dict(sape=4139, guido=4127, jack=4098)
{'sape':4139, 'jack': 4098, 'guido':4127}
5.6.循环
当我们遍历字典的时候,可以通过items()方法将键和值同时取出:
>>> knights = {'gallahad': 'the pure', 'robin': 'the brave'}
>>> for k, v in knights.items():
...	print(k, v)
...
gallahad the pur
robin the brave
当遍历序列(list,tuple(string本质也是tuple),ramge)的时候可以用enumerate()的方法来同时取出索引和相应的值:
>>> for i, v in enumerate(['tic', 'tac', 'toe']):
...	print(i, v)
...
0 tic
1 tac
2 toe
为了可以同时循环遍历两个序列,我们可以用zip()函数来将两个序列进行结对:
>>> questions = ['name', 'quest', 'favorite color']
>>> answers = ['lancelot', 'the holy grail', 'blue']
>>> for q, a in zip(questions, answers):
...	print('What is your {0}? It is {1}.'.format(q, a))
...
What is your name? It is lancelot.
What is your quest? It is the holy grail.
What is your favorite color? It is blue.
为了反向遍历一个序列,第一步先指定一个正向的序列,然后调用reversed()函数.
>>> for i in reversed(range(1, 10, 2)):
...	print(i)
...
9
7
5
3
1
如果我们想要遍历一个已经被排序的序列,可以用sorted()函数来辅助,需要注意的是,sorted()函数会产生一个新的序列,即如果a是一个列表,我做了sorted(a)之后会在内存中区别于a的地方又划分一片空间:
>>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']
>>> for f in sorted(set(basket)):	#此时执行完sorted(set(basket))后会新开辟一片内存空间,for遍历的是这片新空间,而不是basket指定的那片空间
...	print(f)
...
apple
banana
orange
pear
如果我们想在遍历序列的时候改变序列的内容,我们可以通过分片的方法先做一个序列的拷贝,然后对这个拷贝进行遍历,满足条件后对原序列做修改(这个前面已经有过例子了,需要注意的是,分片用的
[:],并且该分片会在内存中单独开辟一片空间;for循环每次都会重新检查一下序列的大小,而非第一次检查后以后都按照这个数进行递增或递减;所以用分片做一个原序列拷贝的好处就是,你检查的是拷贝数据的长度,而插入是向原序列里插入,这样既在遍历时改变了序列,又不会因为for的重复检查而出现死循环,不好的地方是多占用了内存空间如果还不明白的话找找前面的详例)
>>> word = ['cat', 'window', 'defenestrate']
>>> for w in words[:]:	 #这里是另外在内存中开辟了一块空间里面存的内容和words这个序列的内容相同
...	if len(w) > 6:
...		words.insert(0, w)
...
>>> words
['defenestrate', 'cat', 'window', 'defenestrate']

5.7.进一步了解条件控制
用于while循环和if条件语句中的条件控制部分可以包含任何的操作符,而不仅限于比较操作符.
in和not in操作符用来判断一个值是否出现在一个序列中.is和is
not操作符用来比较两个对像是否相同;is和is
not仅仅对像list这种可变对象作用较大,试验了一下对于元组等不可变对象也能用,在网上搜了个例子,看那个例子说的意思是is和is
not是用来判断两个变量在内存的位置是否是一样的,即如果a是b的别名,则a is b是true,它给的例子是判断的id值,我觉得这个id值和内存中的位置有关系,现在是这样理解的,以后接触到官方的解释不对再改吧(这是百度的例子链接:http://zhidao.baidu.com/link?url=FBq46GHjcLMJJYLtmKKOcje5bw4UuO4aZUb1fVHsCsTbC9qAIEEE0P5JER9kCopILWycdITzc303wE8yKCrTJjuqnMnjUv5WqwIR5LcFdfW).所有的比较操作符的优先级是相同的,它们的优先级都低于数值操作符.
在一个条件控制中可以有多个比较符号,如a < b == c 用来判断a是小于b并且b是否等于c.
比较操作符可以和布尔操作符(and,or)结合使用,可以用not将比较的结果或是任何其它的布尔表达式取反(即not false is true,not true is false).这三个符号的优先级要低于比较符;这三个符号的优先级为not优先级最高,or优先级最低,因此A and not B or C可以写成 (A and (not B)) or C.我们在写表达式的时候一直是可以用圆括号的形式来代替优先级
布尔操作符and
和or的运算顺序是从左到右的,在运算的过程中,一旦输出的结果已经确定了,就不会再和下面的运算数做运算了,比如说A
and C is true，但是B是false,则A and B and C这个表达式中,不会计算and C这部分,因为在这个表达式中A and B就已经知道结果了,当然这也是看了C前面是and,如果C前面是or就还要计算
我们还可以将比较的结果或是布尔表达式赋给一个变量:
>>> string1, string2, string3 = '', 'Trondheim', 'Hammer Dance'
>>> non_null = string1 or string2 or string3
>>>non_null
'Trondheim'	#因为第一个or的时间已经为true了,然后又检查后面的操作符为or故第三个string3不做运算了就

5.8.比较序列数据类型和其它类型
看例子吧,原文以后再翻译:
相同序列类型之间可以做比较,至于规则自己看一下吧
(1, 2, 3) < (1, 2, 4)
[1, 2, 3] < [1, 2, 4]
'ABC' < 'C' < 'Pascal' < 'Python'
(1, 2, 3, 4) < (1, 2, 4)
(1, 2) < (1, 2, -1)
(1, 2, 3) == (1.0, 2.0, 3.0)
(1, 2, ('aa', 'ab')) < (1, 2, ('abc', 'a'), 4)
注脚:字典的keys()方法返回的只是一个字典的视图,并没有开辟新的内存空间
