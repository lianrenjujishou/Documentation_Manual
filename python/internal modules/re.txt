
该模块提供了类似于Perl语言中匹配操作的正则表达式.

被搜索的模式和字符串可以是Unicode字符串也可以是8位字符串.可是Unicode字符串和8位字符串不能混合使用:也就是说,你不可以用一个byte模式匹配Unicode字符串,反之亦然;同样地,当请求一个替换时,替换字符串(或叫目的客串是不是更好理解一些)必须和模式字符串及被搜索的字符串是相同的类型.

正则表达式使用反斜杠字符('\')来表示特殊的形式或是允许对那些特殊字符只使用它们字面的意思而不调用它们的特殊函义.在字符串字面意义上有相同目的的相同字符的使用会有冲突(这个冲突是否是正则表达式的写法与模式中的写法的冲突?);例如,为了匹配一个字面意义上的反斜杠,一种是我们必须要写成'\\\\'来作为模式字符串,因为正则表达式必须被\\,并且每个反斜杠在一个正则Python字符串字面变量里又必须表达为\\.

解决方法是为与此同时表达式模式使用Python的原始字符串符号;在有'r'前缀的字符串中反斜杠不会被特殊处理(或说特殊对待).因此当"\n"表示包含一个换行的一个字符时,r"\n"就表示包含两个普通的字符'\'和'n'.通常在Python中模式代码被使用原始字符串符号表示(即在字符串前面加上r,从而将引号中的所有字符都理解为单个普通字符).

注意,在被编译的正则表达式中大多数的正则表达式操作都可以作为模块级别的功能和函数来使用.函数是一条捷径,首先它不需要你去编译一个正则表达式,但是会丢失一些调节的参数.

6.2.1. Regular Expression Syntax
一个正则表达式(或简称RE)指定了字符串要匹配的一个集合;模块中的函数让你检查是否一个特殊的(详细的?)字符串匹配一个给定的与此同时表达式(或者说是否一个给定的正则表达式匹配一个特殊的(详细的?)字符串,这两句说法归根结底做的是同样的事情).

正则表达式可以被连接从而形成一个新的正则表达式;如果A和B都是正则表达式,则AB也是一个正则表达式.一般来说,如果一个字符串p匹配上了A并且字符串q匹配上了B,则字符串pq将会匹配AB.这个特性会保持除非A或B包含优先级比较低的操作;边界条件在A和B之间;或者是拥有已经被编号的组引用.因此复杂的表达式可以很简单的被构建从像在这描述的这些更简单的原始表达式.
下面是关于正则表达式的一个简短描述.更多信息和更优雅的描述可以参考Regular Expression HOWTO

正则表达式可以包含特殊字符和普通字符.像'A', 'a', 或者'0'这种最常见的普通字符就是最简单的正则表达式;他们仅仅匹配它们自己.你可以将普通字符连接起来,因此last会匹配字符串'last'.  (在该章节剩下的部分, 我们会用this special style的方式来写正则表达式,通常不带引号,这个字符串会匹配'in single quotes')

某些字符,像'|' 或者 '(',属于特殊字符.特殊字符或者代表一类普通字符，或者会影响围绕着这些特殊字符 的正则表达式被如何解释.与此同时表达式的模式字符串不能包含null字节,但可以使用\number符号来指定下null字节,例如'\x00'.

表达重复的限定词(修饰语)(*, +, ?,
{m,n},等)不能被直接嵌套.这样就避免了与非贪婪的修饰后缀?和在其它实现中的修饰模棱两可。为了将第二次重复应用到一个内部的重复,必须使用小括号.例如,表达式(?:a{6})*匹配任何多个6个'a'的倍数.

下面这些是特殊字符:
'的倍数.

下面这些是特殊字符:

'.'
(Dot.)在默认的模式下,点字符匹配除了newline符外的任一个字符.如果指定了DOTALL flag,则点字符将会匹配任一字符,包括newline符

'^'
(Caret.)匹配字符串的开始,并且在MULTILINE模式中也会立即匹配每个newline符后面

'$'
匹配字符串的结尾或仅仅匹配在字符串的结尾newline符前面,并且在MULTILINE模式下也会匹配newline符前面.
foo匹配'foo' 和'foobar',
当正则表达式foo$仅仅匹配'foo'时.更有确的是,在字符串'foo1\nfoo2\n'中搜索foo.$通常会匹配'foo2',但是在MULTILINE中会将'foo1'也匹配上;在字符串'foo\n'中搜索单个$字符会发现两个空匹配:一个是仅仅在newline前,一个是在字符串结尾.(自悟:正常情况下是会匹配1.字符串的结尾位置，2.字符串的结尾新行前，但是如果加上re.MULTILINE则$会匹配任意一个新行前而不 仅仅是结尾的新行前，记住$不匹配任何字符它匹配的只是一个位置)
例子: a = 'foo1\nfoo2\n'
      re.findall("$", a)  --> ['', ''],一个是字符串的结尾即第二个\n后面的位置
                                       一个是第二个\n的前面(即所谓的也匹配字符串结 尾的换行符前)
      re.findall("$", a, re.MULTILINE)  --> ['', '', ''],此时是三个空元素，头两个见上面的例子，第三个匹配的是第一个\n前面的位置

'*'
引起"最终的正则表达式"匹配0个或是多个"前面正则表达式"的重复，而且是尽可能多的重复.ab*会匹配'a', 'ab'或是'a'跟着任意数量的'b'如'abbb', 'abbbbbbbb'
**.这里解释一下这句"最终的表达式"，因为*的用处是匹配任意多个前面的正则表达式
   再解释一下"前面的正则表达式",别一看里含有表达式就觉得有多深，别忘了前面说的，普通字符就是最简单的正则表达式

'+'
引起"结果(最终的)表达式"匹配1个或是多个前面正则表达式的重复.ab+会匹配'a'跟着任意非0数量的'b'字符,如'ab', 'abbb', 'abbbbbb'但是它并不会匹配单个'a'

'?'
引起结果表达式匹配0个或1个它前面的正则表达式.ab?仅会匹配'a'和'ab'

*?, +?, ??
'',
''和''修饰符都是贪婪的;它们会尽可能多的匹配文本.有时这种贪婪匹配的行为不是我们所期望的;如果用正则表达式<.*>去匹配<a>b<c>,则会将整个字符串都匹配上,而不仅仅是<a>.在贪婪修饰符后加上?号则执行的就是非贪婪的匹配或是最小的匹配(这里用的是minimal
fashion,这个fashion不知翻译成啥估且都叫匹配吧),它们会在满足所给正则表达式的前提下尽可能少的匹配.使用正则<.*?>仅仅匹配<a>
**.写一下自己的理解吧,使<.*>和<.*?>来举例
<.*>在匹配的时候侧重点在于>是不是给定字符串中的最后一个>,而
<.*?>在匹配的时候侧重点在于下一个字符是否是>

{m}
指定精确的m个前面正则表达式的副本;较少的匹配导致整个正则不会匹配.例如,
a{6}会精确的匹配6个'a',而不是5个.

{m, n}
导致最终的正则表达式匹配前面正则表达式从m个到n个这个区间的重复,会尝试着尽可能多的匹配.例如, a{3, 5}会匹配从3到5个'a'字符.如果m指定一个低于0的值则会被忽略,同样n指定一个无上限的值也会被忽略.例如, a{4,}b会匹配aaaab或者一等个'a'字符跟着一个'b',但不匹配aaab.这里的逗号不能被忽略否则修饰符会拒绝之前的描述形式 
**.这里面有一句start不能为负,end不能为无穷大，试了一下，如果start为负数了,则结果返回的是一个空列表,如果start正常end为一个很大很大的数则会抛出一个溢出异常，但是end如果为一个不是很大的数就正常，所以最后再确定一个这里面的MAXREPEAT是如何确定的

{m, n}?
引起结果与此同时表达式会匹配从m到n个前面正则的副本,尝试着尽可能少的匹配.这是前面修饰符的非贪婪版本.例如在含有6个字符的字符串'aaaaaa'中,a{3,5}会匹配5个'a'字符,而a{3,5}仅仅会匹配3个'a'字符

'\'
或者转义特殊字符(允许你去匹配像'*', '?'等等这样的字符),或者标志一个特殊的序列;特殊序列会在下面讨论:

如果你没有使用原始字符串来表达模式,记住,Python也在字符串字面值中使用反斜框作为一个转义序列;如果转义序列没有被Python的解释器识别的话,则反斜杠和随后的字符会被包含在结果字符串中.然而,如果Python将要识别结果序列的话,反斜杠应该被重复2次.这是复杂的并且难以理解的,因此除了最简单的表达式外，高度推荐使用原始字符串(raw string,即在字符串前面加上r)

[]
被用来表示字符集合.在集合中:
    a.字符可以被单独列出来,如[amk]会匹配'a', 'm'或是'k'.
    b.字符的范围可以通过给定的两人个字符和分隔这两个字符的'-',例如[a-z]会匹配任何一个小写的ASCII字母, [0-5][0-9]会匹配所有的从00到59的两位数,[0-9A-Fa-f]会匹配任意一个十六进制数字.如果-被转义(例如[a\-z])或者如果-在[]中是第一位或是最后一位(如[-a], [a-])则-不再是范围的连字符，而仅仅匹配-本身
    c.在集合中(sets或[])特殊字符会失去特殊意义.例如,[(+*)]会匹配'(','+','*',')'中任何一个字面意思的字符.
    d.字符集合中也可以包含表示某一类的字符如如下面要讲到的\w或\S,尽管某一类字符所匹配到的字符依赖于是否ASCII模式或LOCALE模式是强制的(in force)
    e.通过补充集合(set,[])可以匹配上没有在这个集合里的内容.如果集合中第一个字符是'^',则会匹配所有没有在该集合中的字符.例如,[^5]会匹配除'5'外的任意一个字符,[^^]会匹配除'^'外的任意一个字符.如果'^'没有在集合中的开头则它没有任合特殊意义(言外之意只表示它本身)
    f.为了在集合中(sets,[])匹配一个字面值']',要在']'字符前放置一个反斜杠,或者如果不想在']'前面加反斜杠可以将']'放在集合的最前面.例如,[()[\]{}] 和[]()[{}] 都会匹配插入成分(说的应该就是匹配']'或者说的是一对对的括号,需要注意的是它的另一半正常写即可没啥特殊的)

'|'
A|B,这里A和B可以是任意的正则表达式,创建一个即可以匹配A又可以匹配B的正则表达式.通过这种方式可以用'|'分隔任意多的正则表达式(开头举的例子是两个，A和B).'|'也可以被用于分组内(看下面).当目标字符串被扫描时,由'|'分隔的正则表达式会从左到右进行匹配.当其中一个模式完成了匹配,那个分支就被接受了.这意味着一旦A正则匹配上了,B就不会再尝试着去做更深的匹配了,即使它(这里的它应该指的是B)会产生一个较长的完全匹配.换句话说,'|'操作符不是贪婪的.为了匹配一个字面意义的'|'可以使用'\|',或者将'|'放在集合中[|].
**.其实这个'|'一开始接触看似好理解，其实也不是那么好理解的，这里给个例子
   a = "11123"
   re.findall("111|[123]", a)  --> ['111','2', '3']
   re.findall("[123]|111", a)  --> ['1', '1', '1', '2', '3']
给这两个例子是要说明两个问题，一是在用字符串去和模式匹配时虽说模式有多个，但是遵循从左到右的方式；二是我要着重说明的：后面的模式不会从头开始对字符串进行匹配，而是从当前字符进行匹配，这里的当前字符指的是上个字符是和上一个模式匹配的，当扫描到当前字符时和上一个模式不匹配了，则用下一个模式继续和当前模式匹配，一直这样循环这也就解释了第一个例子为什么模式中明明有[123],得到结果确不是['1', '1', '1', '2', '3']而是['111', '2', '3']了
*.如果模式只是|则默认匹配的是空位  re.findall("|", "111")  -->['', '',
'',''],因为三个1会隔成4个空位嘛,你直接写|系统应该也会检测它两边的内容，所以会用两个''作为匹配的模式

(...)
匹配无论括号里的正则表达式是什么,并且表示一个组的开始和结束;一个组的内容可以被检索在一个匹配已经被执行之后,并且稍后可以使用\number特殊序列来匹配,下面有描述.为了匹配字面值'('或')'可以使用\(或\),也可以将括号字符放到字符集中(sets,[]):[(][)]

(?...)
这是一个扩展符号(否则一个'?'跟着一个'('是无意义的).'?'后面的第一个字符决定了这个结构的意义和进一步的语法是什么.扩展通常不会创建一个新组;(?P<name>...)是唯一一个对于该条规则例外的.下面是当前支持的扩展

(?aiLmsux)
(来自集合'a', 'i', 'L', 'm', 's', 'u', 'x'的一个或多个字母.)这个组匹配空字符串;这些字母设置相应的flags：re.A(仅仅匹配ASCII码), re.I(忽略大小写)， re.L(依赖于本地的环境), re.M(多行), re.S(点匹配所有), re.X(冗余),对于整个正则表达式.(这些flags被描述在Module Contents中.)如果你想要将这些flags作为正则表达式的一部分则这是有用的,代替传递一个flag参数到re.compile()函数.
*.如果要让(?aiLmsux)作为正则表达式,则其实匹配的和单独一个'|'一样，匹配的是空字符串

注意,(?x)标志改变这个表达式是如何被解析的.它首先应该被使用在表达式字符串中,或是一个或多个空白字符中.如果在该标志前有非空白字符,结果是未定义的(undefined)

(?:...)
正则括号(插入语？)的一个非捕获版本.捕获无论括号中的正则是什么,但是在模式中执行一个匹配或是被引用之后,通过分组匹配到的子串不能被检索.
*.对于该选项还有疑问，和()有什么区别，所谓的不能被检索是什么意思
*.而且对于括号分组初学者有一个不好理解的地方，例re.findall("(aa)b","aaab"
),这句话查找的其实只是括号里的内容，而不是整个"(aa)b",最终的解释是匹配'aa',什么样的'aa'呢，是后面跟着一个字符'b'的'aa'。所以说这一点一定要注意

(?P<name>...)
类似于正则括号,但是由(?P<name>...)这个组匹配到的子串是可以通过设置的name进行访问的.组名name必须是有效的Python识别符,在一个正则表达式中每个组名必须只能被定义一词.一个符号组也是一个被编号的组,仅仅是好像这个组没有被命名.

被命名的组可以在三个上下文中被引用.如果模式是(?P<quote>[' ""]).*?(?P=quote)(例如匹配一个用单引号或双引号引起来的字符串):
#######################################################################
Context of reference to group "quote"      |      Ways to reference it
-----------------------------------------------------------------------
in the same pattern itself                 |     1.(?P=quote)(as shown)
                                           |     2.\1
-----------------------------------------------------------------------
when processing match object m             |     1.m.group('quote')
                                           |     2.m.end('quote')(etc.)
-----------------------------------------------------------------------
in a string passed to the repl argument    |     1. \g<quote>
of re.sub()                                |     2. \g<1>
                                           |     3. \1
-----------------------------------------------------------------------

(?P=name)
对一个命名组的反向引用;它匹配无论命名为name的较早的组匹配上了什么样的文本

(?#...)
一个注释;括号中的注释仅仅被忽略

(?=...)
如果...匹配上了下个内容,但是不会消耗任何字符串.这被称为向前看断言.例如,Isaac (?=Asimov)会匹配'Isaac'仅当'Isaac'后面紧跟着'Asimov'时 *.可以看出该组是用来当配角的，真正的主角是该组前面的内容

(?!...)
如果...没有匹配下个内容,则匹配上前面的内容.这是一个反向断言.例如,Isaac (?!Asimov)仅仅当'Isaac'后面没有紧跟着'Asimov'时,才会匹配'Isaac'
*.可以看出来和上面的(?=...)一样，主角都是其前面的内容

(?<=...)
如果在字符串中当前位置前面匹配上了....这被称为积极向后断言.(?<=abc)def会在'abcdef'中发现一个匹配,由于向后看会倒退3个字符来检测是否匹配包含的模式.包含的模式必须只匹配某些固定长度的字符串,意味着'abc'或是a|b是允许的,但是a*和a{3,
4}是不允许的.注意,以积极向后断言开始的模式不会匹配被搜索字符串的开头;你最可能想要使用search()函数而不是match()函数:
>>> import re
>>> m = re.search('(?<=abc)def', 'abcdef')
>>> m.group(0)
'def'
下面这个例子查找一个跟着hyphen的单词:
>>> m = re.search('(?<=-)\w+', 'spam-egg')
>>> m.group(0)
'egg'
*.翻译我是没看明白，但是给的这两个例子基本上能明白用法了
在3.5版本中被改变: 添加了对固定长度的组引用

(?<!...)
如果在字符串的当前位置前面没有...则匹配,这被称为消极的向后断言.类似于积极向后断言,被包含的模式必须仅匹配某些固定长度的字符串.以消极向后断言开始的字符串可以匹配被搜索字符串的开头.

(?(id/name)yes-pattern|no-pattern)
会尝试着使yes-pattern来匹配如果以id或是name指定的组存在的话,如果以id或name指定的组不存在则使用no-pattern去匹配.no-pattern是可选的，可以字忽略.例如,(<)?(\w+@\w+(?:\.\w+)+)(?(1)>|$)是一个不好的邮件匹配模式,会用'<user@host.com>'或是'user@host.com'去匹配,而不会用'<user@host.com>'或'user@host.com>'去匹配

特殊的序列由'\'和一个来自下面列表中的一个字符组成的.如果普通字符不在列表中,则结果表达式匹配第二个字符.例如,\$匹配的只是字符$.

\number
匹配相同number的组的内容.组是从1开始编号的.例如,'(.+) \1'会匹配'the the'或是 '55 55',但是不匹配'thethe'(因为我们要注意在模式中有一个空格).这种特殊序列只能够匹配到头99组之一.如果编号的第一个数字是0,或者编号是3个八进制数字长,则不会被解释为一个组匹配,而是作为拥有八进制值数字的字符.在'['和']'中的一个字符类,所有的数字转义都被作为字符.

\A
只匹配字符串的开始

\b
匹配空字符串,但是仅仅在一个字的开头或结尾.字的定义为一个由Unicode字母数字或下滑线字符组成的序列,因眦一个字的结尾通常被空白或是一个非字母数字，非下滑线的Unicode字符表示.注意形式上,\b被定义为\w和\W(反之亦然),或者\w和一个字符串开头或结尾的边界.这意味着r'\bfoo\b'匹配'foo', 'foo.', '(foo)', 'bar foo baz'但是不匹配'foobar'或'foo3'.

默认情况下,Unicode字母数字是被使用的这些,但是这种形为可以通过使用ASCII flag来改变.在一个字符范围中,\b表示退格字符,为了和Python的字面意义的字符串相兼容
*.就\b说几点
*.1.word的定义为由字母数字下划线组成的序列
*.2.通常情况下可以用空白或是非字母数字且非下划线来表示一个字的结尾
*.3.\b被定义为一个边界,什么边界呢，\w和\W 或是 \w和字符串的开始或结尾 的边界

\B
匹配空字符串,但是仅仅是当它不在一个字的开头或结尾时.这意味着r'py\B'会匹配'python',
'py3', 'py2',但是不能是'py','py.'或'py!'.  \B仅仅是和\b相反,所以字是Unicode数字字母或是下滑线,尽管这个行为可以通过使用ASCII flag改变

\d
对于Unicode(str)模式:
    匹配任何一个Unicode十进制数字(也就是说,Unicode字符类别[Nd]中的任意一个字符).这包括[0-9], 也包括其它的数字字符.如果ASCII flag被使用则仅仅[0-9]被匹配(但是这个flag会影响整个正则表达式,因此像这种情况下使用一个精确的[0-9]会是一个比较好的选择)

对于8-bit(bytes)模式:
    匹配任何的十进制数字,即等价于[0-9]

\D
匹配任何一个非Unicode十进制数字.这和\d是相反的.如果使用ASCII flag则\D等价于[^0-9](但是这个标志影响整个正则表达式,因此在这种情况中使用一个精确的[^0-9]是一个比较好的选择).

\s
对于Unicode(str)模式:
    匹配Unicode空白字符(包括[ \t\n\r\f\v],和许多其它字符,例如在许多语言中被排板规则强制性的非打断空格).如果ASCII标志被使用,仅仅[ \t\n\r\f\v]被匹配(但是这个标志影响了整个正则表达式,因此在这种情况下使用一个精确的[ \t\n\r\f\v]是一个不错的选择).

For 8-bit(bytes)模式:
   匹配在ASCII字符集中被考虑的空白;等价于[ \t\n\r\f\v].

\S
匹配任何一个非Unicode空白字符.\S正好和\s相反。如果ASCII
flag被使用则\S等价于[^\t\n\r\f\v](但是flag会影响整个正则,因此在这种情况下使用一个精确的[^\t\n\r\f\v]是一个比较好的选择).

\w
对于Unicode(str)模式:
匹配Unicode字字符;它包括大多数的字符,这些字符是大多数语言中字的一部分,也可以是数字和下划线.如果ASCII flag被使用,仅仅[a-zA-Z0-9_]被匹配(但是flag会影响整个正则表达式,因此在这种情况下使用一个精确的[a-zA-Z0-9_]是一个比较好的选择)

对于8-bit(bytes)模式:
匹配被考虑在ASCII字符集中的字母数字;这等价于[a-zA-Z0-9_]


\W
匹配任何一个非Unicode字字符的字符.这和\w正好相反.如果ASCII
flag被使用则\W等价于[^a-zA-Z0-9_](但是flag影响整个正则表达式,因此在这种情况下使用一个精确的[^a-zA-Z0-9_]是一个比较好的选择).

\Z
仅仅匹配字符串的结尾
*.和\A正好相反，同时再联想一下,A和Z是26个字母中的首尾字母，在这里表达的意思也正好和A与Z在26个字母中的位置相呼应

大多数被Python字符串字面变量支持的标准转义也被正则表达式的解析器所接受:
\a	\b	\f	\n
\r	\t	\u	\U
\v	\x	\\
(注意,\b被用来表示字的边界,并且仅仅在字符类(这里的字符类应该就是我说的字符集不敢100%保证)中表示退格(backspace))

'\u' 和'\U'转义序列仅仅在Unicode模式中被识别.在bytes模式下它们不会被特殊对待.

八进制转义被包含在一个受限的格式中.如果第一个数字是0,或者如果有三个八进制数字,则会被考虑为一个八进制转义.否则,会被作为一个组引用.至于(关于)字符串字面值,八进制转义总是在最多三个数字的长度.

在3.3版本中被改变: '\u' 和'\U'转义序列已经被添加

在3.5版本中被弃用,在3.6版本中将会被移除:由'\'和ASCII字母组成的未知转义现在会抛出一个被弃用的警告并且在Python3.6中会被禁止.

See also:
Mastering Regular Expressions 由O'Reilly出版的关于Jeffrey Friedl写的关于正则表达式的书.该书的第二版不再覆盖Python,但是第一版中覆盖的写关于正则表达式模式的是非常详细的

多数重要的应用一直使用的是编译的形式.

re.compile(pattern, flags=0)
编译一个正则表达式模式到一个正则表达式对象,这个正则表达式对象可以使用match()和search()方法进行匹配,描述如下.

表达式的行为可以通过指定一个falgs值进行修改.flags值可以是下列变量的任意一个,combined using bitwise OR(|操作符)(这句话暂翻译为使用按位OR来编译(混合?)的变量(用来修饰前面的variables))

序列:
prog = re.compile(pattern)
result = prog.match(string)
等价于:
result = re.match(pattern, string)

但是当一个表达式在单个程序里面要被复用几次的时候,用re.compile()并且保存正则表达式对象的结果,是更有效的.

Note:
被传递到re.compile()中最新模式和模块级别的匹配函数的编译版本被缓存,因此一次使用很少的正则表达式时不用担心编译正则表达式.

-------------------------------------------flags start---------------------------------
re.A
re.ASCII
使得\w \W \b \B \d \D \s \S只执行ASCII匹配而非完整的Unicode匹配(从这也能看出来ASCII应该是Unicode子集或是啥的,虽然没细看呢,但是前者支持的东西肯定没有后者多).该flag仅对Unicode模式是有意义的,对于byte模式即使加上也会被忽略,即对byte模式无意义.

注意,考虑到向后兼容,re.U flag一直是存在的(和re.U同义的re.UNICODE和re.U的内嵌副本(?u)也是支持的),但是这个标志对于Python3来说是多于的,因为在Python3中默认的字符串编码就是Unicode(Unicode匹配不考虑bytes模式)

re.DEBUG
显示出被编译的表达式的调试信息.

re.I
re.IGNORECASE
执行忽略大小写的匹配;表达式[A-Z]也会匹配小写字母.这个flag不受当前的locale的影响并且不出所料,也为Unicode字符工作.

re.L
re.LOCALE
使得\w \W \b \B \s \S依赖于当前的locale(环境变量的意思).这个flag的使用是被劝阻的因为locale mechanism(本地环境机制)是非常不可靠的,无论如何它一次只处理一个"culture";你应该使用Unicode匹配来代替它,在Python3中字符串匹配默认使用的就是Unicode模式.这个flag仅仅在bytes模式下有意义.

在版本3.5中被弃用,将会在版本3.6中移除:废除在字符串模式中使用re.LOCALE或者是re.ASCII.

re.M
re.MULTILINE
当指定这个flag,模式字符'^'匹配字符串的开始和每行的开始(紧跟着每个换行);模式字符'$'匹配字符串的结尾和每行的结尾(immediately在每个换行之前).默认情况下,'^'紧匹配字符串的开始,'$'仅匹配字符串的结尾和字符串结尾的新行前.

re.S
re.DOTALL
使得'.'这个特殊字符完全匹配任意一个字符,包括换行;不带这个flag时,'.'匹配除换行外的任意一个字符.

re.X
re.VERBOSE
该flag可以帮你将正则写的更漂亮,可读性更强(通过将模式分隔为几块)并且允许添加注释.除非空白字符在一个字符集中或是空白字符前面有一个非转义的反斜杠外,其它情况下模式中的空白被忽略.当一行中包含一个不在字符集中(这里的字符集是否指的是在[]之类符号里面的?)或者前面没有放置一个非转义的反斜杠的#号时,从该#号开始到行尾的字符都会被忽略(言外之意就是作为注释被忽略).

从上面这句话可知下面这两个匹配十进制数字的正则对象在功能上是相等的:
a = re.compile(r"""\d + # the interal part
                   \.   # the decial point
                   \d * # some fractional digits""", re.X)
b = re.compile(r"\d+\.\d*")
*.在第一个式子中用的是"""而不是"或',所以是否re.X是和"""一起用呢
-------------------------------------------flags end---------------------------------
re.search(pattern, string, flags=0)
扫描字符串查找第一个位置,在这个位置正则表达式模式产生一个匹配,并且返回一个相应的匹配对象.如果字符串中没有匹配上给定模式则返回None;注意这不同于在某种情况下在字符串中查找一个0长度的匹配.

re.match(pattern, string, flags=0)
如果在字符串开始的0个或多个字符匹配上了给定的正则表达式模式,则返回一个相应的匹配对象.如果字符串没有匹配上给定的模式则返回None;注意这不同于一个0长度的匹配.

注意,即使是在MULTILINE模式下，re.match()也仅仅匹配字符串的开始而并不会匹配每一行的开始.

如果你想要定位字符串中的所有匹配,可以使用search()代替(看一下seach() vs match()).
*.目前看search()和match()的区别是前者会在字符串的任意位置匹配,而后者只匹配字符串的开头

re.fullmatch(pattern, string, flags=0)
如果整个字符串匹配给定的正则表达式模式,则返回一个相应的匹配对象.如果字符串没有匹配上给定的模式则返回None;注意这和0长度匹配还不一样.

在3.4版本中新加入的.

re.split(pattern, string, maxsplit=0, flags=0)
通过pattern的出现来分割字符串.如果捕捉括号被用在模式中,则模式中所有组的文本也会被作为结果列表的一部分返回.如果maxsplit是非零的,at most maxsplit splits occur(暂译为大多数情况maxsplit splits会发生),字符串剩下的部分被作为列表的最后元素返回

>>> re.split('\W+', 'Words, words, words')
['Words', 'words', 'words.', ''] #可以看出即使字符串全都被匹配上,也会将"剩余的"空字符串给放到列表后面
>>> re.split('(\W+)', 'Words, words, words.')
['Words', ', ', 'words', ', ', 'words', '.', '']
>>> re.split('\W+', 'Words, words, words.', 1)
['Words', 'Words, words.']
>>> re.split('[a-f]+', '0a3B9', flags=re.IGNORECASE)
['0', '3', '9']
*.在理解头两条语句时,结果中最后都是空字符串,要理解为当定位到最后一个.时,点前面的是words,点后面的自然就是空了.

如果在分隔符中有捕获组并且该捕获组匹配在字符串的开头,则产生的结果列表的第一个元素是空字符串.如果捕获组匹配上了字符串的结尾则产生的结果列表的最后一个元素是空字符串(为也验证了我上一段所说的,匹配的时候它只负责找分隔符,而无论找到的分隔符两边是什么,两边找到东西了就将实际的输出到列表中,如果没找到,就是分隔符捕获到结尾或是开头的情况,则会将一边的空字符串输出).

>>> re.split('(\W+)', '...words, words...')
['', '...', ', ', 'words', '...', '']
*.上面那句话的实践只得到了,只要模式匹配到了开头或是结尾,就会在结果列表的开头或结尾产生一个空字符串;而跟捕获组不捕获组对应不上

在上面例子中,分隔符组件总是在结果列表中同样的相对指标被找到(应该想要表达的意思就是说在返回的列表中分隔符的位置和分隔符在字符串中的位置是一样的)

Note: split()一般不使用空分隔符去分割字符串.如:

>>> re.split('x*', 'axbc')
['a', 'bc']   # 'x*'可以产生空字符串,但是实际上,程序没使用空字符串作为分隔符

即使'x*'也匹配'a'前有0个'x','b'和'c'之间,'c'后面,但是当前这些匹配都被忽略.正确的行为(例如,如果上面的例子也用空字符串分割会返回['', 'a', 'b', 'c', ''])会在Python将来的版本中实现,但是由于这是一个向后兼容的改变,所以在这期间一个FutureWarning会被抛出.

仅仅匹配空字符串的模式一般(当前?)不分割字符串.因为空字符串模式不匹配期望的行为,从Python3.5版本起一个ValueError会被抛出:

>>> re.split("^$", "foo\n\nbar\n", flags=re.M)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  ...
ValueError: split() requires a non-empty pattern match.

在3.1版本中改变的:添加了可选的flags参数
在3.5版本中改变的:支持空字符串模式去分割但是会抛出一个警告.仅仅能匹配空字符串的模式现在被拒绝(就是说模式为'x*'的这个例子,现在会产生两种结果,一种是FurtureWarning警告另一种是产生一个列表).

re.findall(pattern, string, flags=0)
返回一个由所有匹配上给定模式的非重复的匹配组成的字符串列表.字符串被扫描的方式是从左到右,并且返回的字符串列表中元素的顺序就是扫描字符串时发现的顺序.如果一个或是多个组存在于模式中,则返回一个组列表;如果模式中含有多于一个的组则返回一个元素列表.空匹配也会被包括在结果列表中除非它们(这个它们应该指的是空吧?)匹配上了另一个匹配的开始

re.finditer(pattern, string, flags=0) 返回一个迭带器,该迭带器中的内容是由在字符串中匹配模式所产生的.并且扫描字符串的时候是从左到右的顺序,而迭带器中的元素的顺序和扫描时发现匹配的顺序是一样的.字的匹配也被包含在结果中除非它们(应该指的是空字符串吧?)匹配上了另一个新的匹配的开头(迭带器和元素这块是我按照意思乱翻译的,只是为了方便现在好理解,以后有更精确的解释再回头改)

re.sub(pattern, repl, string, count=0, flags=0)
返回字符串,啥样的字符串呢,就是通过用repl替换最左面非重叠出现的模式来获得的字符串.如果模式没有被发现,则字符串原样返回.repl可以是一个字符串也可以是一个函数;如果repl是一个字符串,则包含在其中的反斜杠也被会处理.也就是说,字符串中的\n被转换为一个换行符,\r被转换为一个回车,等等.像\&这种未知的转义则被遗弃(是\被遗弃还是\&都被遗弃,目前猜测为前者).像\6这种反向引用,也会用模式中的第6组被匹配上的子字符串去替换.例如:

>>> re.sub(r'def\s+([a-zA-Z_][a-zA-Z_0-9]*)\s*\(\s*\):',
...        r'static PyObject*\npy_\1(void)\n{',
...        'def myfunc():')
'static PyObject*\npy_myfunc(void)\n{'

如果repl是一个函数,它被每一个非重叠出现的模式所调用.函数需要一个匹配对象参数,并且返回替换的字符串.

>>> def dashrepl(matchobj):
...     if matchobj.group(0) == '-': return ' '
...     else: return '-'
>>> re.sub('-{1,2}', dashrepl, 'pro----gram-files')
'pro--gram files'
>>>re.sub(r'\sAND\s', ' & ', 'Baked Beans And Spam', flags=re.IGNORECASE)

模式可以是一个字符串或是一个正则表达式对象.

可选参数count是要被替换的模式出现的最大次数;count必须是一个非负整数.如果被忽略了或者为0,则所有的出现都会被替换.模式的空匹配被替换仅仅是当没有邻近一个先前的匹配,因此sub('x*','-', 'abc')返回'-a-b-c-'

在字符串类型repl参数中,除了上面提到的字符转义和反向引用外,\g<name>将使用通过被命名为name的组匹配到的子串,按照通过(?P<name>...)语法定义的.\g<number>使用相应的组号;因此\g<2>等价于\2,但是是清晰的在一个像\g<2>0这样的替换中.\20将被解释为到组20的引用,而不会解释为一个到组2并且后面跟着字面意义的字符'0'的引用.反向引用\g<0>在整个被正则匹配上的子串替换.

在版本3.5中改变的:没有匹配的组被空字符串替换.

自从3.5版本被弃用,在3.6版本中会被移除:由'\'和ASCII字符组成的未知转义现在会抛出一个弃用警告并且会在Python3.6中被禁用.

re.subn(pattern, repl, string, count=0, flags=0)
执行和sub()相同的操作,但是它返回的是一个tuple(new_string, number_of_subs_made)

在3.1版本中改变的:添加了可选参数flags

在3.5版本中改变的:未改变的组被用空字符串替换

re.escape(string)
转义模式中的所有字符除了ASCII字符,数字和'_'.这对于要匹配含有正则元字符的任意字面意义的字符串来说是有用的.

在3.3版本中改变的:'_'字符不再被转义

re.purge()
清除正则表达式缓存.

exception re.error(msg, pattern=None, pos=None)
当一个被传递到这里函数之一的字符串不是一个有效的正则表达式时会抛出异常(例如,字符串可能包含了未匹配的括号)或者当在编译或是匹配时发生了其它的错误也会抛出异常.如果一个字符串没有匹配上任何节模式那从来都不是一个错误.函数实例有下面的额外属性:

msg
未格式化的错误信息

pattern
正则表达式模式

pos
编译失败处的模式引索

lineno
与pos相一致的行

colno
与pos相一致的列 在3.5版本中改变的:添加了额外的属性.  
6.2.3. Regular Expression Objects
编译的正则表达式对象支持下列的方法和属性:

regex.search(string[, pos[, endpos]])
扫描字符串查找第一个和给定正则表达式相匹配的位置,并返回一个相应的匹配对象.如果字符串中没有匹配上给定的正则表达式,则返回None;注意这和某种情况下在字符串中查找一个0长度的匹配是不同的.

第二个参数pos是可选的,它的作用是给出一个索引,指示我们从字符串中的什么位置开始搜索;pos的默认值是0.这不完全等同于对字符串的分片;'^'字符匹配字符串的真实开始,这个位置刚好在一个换行之后,但是未必是在开始搜索的索引处.

可选参数endpos限定了字符串将被搜索多远;它呈现的效果是好像字符串就endpos这么长,因此仅仅搜索pos到endpos-1这段字符串进行模式匹配;如果endpos小于pos,则不会有匹配被发现;否则,如果rx是一个被编译的正则表达式对象,rx.search(string, 0, 50)等价于rx.search(string[:50], 0)

>>> pattern = re.compile("d")
>>> pattern.search("dog")   # Match at index 0
<_sre.SRE_Match object; span=(0, 1), match='d'>
>>> pattern.search("dog", 1)  # No match; search doesn't include the "d"

regex.match(string[, pos[, endpos]])
如果有0个或是多个字符匹配上了给定字符串的开头,则返回一个相应的匹配对象.如果字符串没有匹配上给定的模式,则返回None;注意这不同于匹配一个0长字符串.

pos参数和endpos参数和search()方法中讲的相同.

>>> pattern = re.compile("o")
>>> pattern.match("dog")  # No match as "o" is not at the start of "dog"
>>> pattern.match("dog", 1)  # Match as "o" is the 2nd character of "dog".
<_sre.SRE_Match object; span=(1, 2), match='o'>

如果你想要定位字符串的任意位置而非只是开头的话可以使用search()来代替match()(具体的可以看一个search() vs. match()).

regex.fullmatch(string[, pos[, endpos]])
如果整个字符串匹配上了给定的正则表达式,则返回一个相应的匹配对象.如果字符串没有和给定的模式相匹配上,则返回None;注意这不同于匹配一个0长度的字符串.

可选参数pos和endpos和search()方法中介绍的相同,不明白的可返回查看.

>>> pattern = re.compile("o[gh]")
>>> patter.fullmatch("dog")  # No match as "o" is not at the start of "dog".
>>> pattern.fullmatch("ogre")  # No match as not the full string matches.
>>> pattern.fullmatch("doggie", 1, 3) #Matches with given >>> limits(第1位开始第3-1位结束,即'og')
<_sre.SRE_Match object; span=(1, 3), match='og'>
*.通过例子可以知道,当匹配上以后回显中的span后面括号中的数字显示的是你(第一次?)匹配上的内容的位置,就该例来说为1到3-1,和list一样,不包括尾数

在版本3.4中新添加的.

regex.split(string, maxsplit=0)
和上一节的re.split()相同,只不过这里是将上一节的pattern参数换了一种形式罢了(正则表达式对象)

regex.findall(string[, pos[, endpos]])
和上一节提到的findall()函数相似,只是这里将pattern换了一种形式(正则表达式对象),但是它也接受pos和endpos参数来限制搜索的区域,有点像match()

regex.finditer(string[, pos[, endpos]])
和上一节的finditer()函数类似,只不过是将pattern换了一种形式罢了(正则表达式对象),但是也接受可选的pos和endpos参数来限制搜索的范围,类似于match()

regex.sub(repl, string, count=0)
和上一节的sub()函数相同,只不过上一节pattern是出现在参数的位置,这里是将pattern给编译为正则对象,然后用正则对象去调用sub()函数,结果其实是一样的,形式不同而已.

regex.subn(repl, string, count=0)
等同于上一节提到的subn()函数,只不过上一节pattern是出现在参数的位置,这里是将pattern给编译为正则对象,然后用正则对象去调用sub()函数,结果其实是一样的,形式不同而已.

regex.flags
正则表达式的flags.这是一个被给到compile()函数中的flags的结合,在模式中的任何内联flags,和隐式的flags如UNICODE如果模式是一个Unicode字符串.

regex.groups
在模式中捕获组的编号

regex.groupindex
一个由任意被(?P<id>)定义的符号组名到组编号的映射组成的字典.如果模式中没有使用符号组,则字典是空的.

regex.pattern
模式字符串，从这个模式字符串正则表达式对象被编译.

6.2.4. Match Objects
匹配对象总是有一个布尔值True(接后一句这一句我觉得应该翻译为匹配成功的对象应该总有一个布尔值True).因为match()和search()如果没有匹配上的话会返回None,你可以用一个简单的if语句来测试一下匹配是否成功:

match = re.search(pattern, string)
if match:
    process(match)

匹配对象支持下列的方法和属性:
*.感觉它这里面提到的'匹配对象'目前指的应该就是r=re.match()和m=re.search()中的r和m

match.expand(template)
返回通过用反斜杠替换模板字符串template后的字符串,和sub()方法干的事差不多.转义符,例如\n会被转义为适当的字符;数字反向引用(\1,\2)和命名反向引用(\g<1>,\g<name>)被相应组的内容所替换.

match.group([group1, ...])
返回一个或多个匹配到的子组.如果只有一个参数,则结果是一个('一'重读,强调的是'一')字符串;如果有多个参数,则结果是一个元组,且该元组的元素个数和给出的参数个数相同.在没有参数的情况下,group1默认是0(即将整个匹配给返回).如果一个groupN参数是0,则返回的字符串为整个匹配的字符串;如果组号在范围[1到99],则返回的字符串就是相应的组匹配到的字符串.如果一个组号是负的或是大于模式中定义的组号,则会抛出一个IndexError异常.如果一个组被包含在一个没有匹配上的模式里,则相应的结果是None。如果一个组被包含在被匹配了多次的模式的一部分,则将最后一次匹配上的字符串返回.

>>> m = re.match(r"(\w+) (\w+)", "Isaac Newton, physicist")
>>> m.group(0)  # 返回完整的匹配(The entire match)
'Isaac Newton'
>>> m.group(1)  #第一个被括号包围的子组(The first parenthesized subgroup)
'Isaac'
>>> m.group(2)  #第二个被括号包围的子组(The second parenthesized subgroup)
'Newton'
>>> m.group(1, 2)  #由多个参数组成的元组(Multiple arguments give us a tuple)
('Isaac', 'Newton')
*通这这个例子再看上面的那段话,解释几个词,第一个是模式中定义的组数,其实指的就是第一个参数里面有几对括号,像这个例子模式中定义的组数就是2;最后一句可以用例子r = re.match("(..)+", "abcdef")  r.group(1) 去理解.

如果正则表达式使用(?P<name>...)语法,则groupN也可以是一个字符串(组名)通过组名来识别组.如果一个字符串参数在模式中没有被用作组名,则会抛出一个IndexError的异常.(也就是说group()中也可以不是1,2,3这样的数字,可以是字符串，但是这个字符串不是说咱们瞎写的,必须是模式中使用(?P<name>...)语法,则正确的字符串为该语法中name指定的内容.)

下面给出一个稍微(适度)复杂一点的例子:

>>> m = re.match(r"?P<first_name>\w+ (?P(last_name)\w+)", "Malcolm Reynolds")
>>> m.group('first')
'Malcolm'
>>> m.group('last_name')
'Reynolds'

被命令的组也可以通过它们的位置索引来引用它们:

>>> m.group(1)
'Malcolm'
>>> m.group(2)
'Reynolds'

如果一个组匹配了多次,则仅仅最后一次匹配是accessible(被接受的,可理解的):

>>> m = re.match(r"(..)+", "a1b2c3")  # 匹配了三次(Matches 3 times)
>>> m.group(1)  # 仅仅将最后一次的匹配返回(Returns only the last match)
'c3'

match.groups(default=None)
返回一个由所有匹配到的子组所组成的元组,从1开始到最后一组,无论有多少组.默认的参数被用于不参加匹配的组(通过下面第二个例子,可以看出该默认参数用来指定没有匹配上的组的默认值,即如果groups('0')时,我在模式中给出10个组,但是其实第一个组就已经完全将给定的字符串给匹配完了,所以此时生成的元组为('字符串', 9个0));默认是None

例如:

>>> m = re.match(r"(\d+)\.(\d+)", "24.1632")
>>> m.groups()
('24', '1632')

如果我们在整数后面放置可选的小数或是其它任何东西,则并不是所有的组都参加匹配.则这些组将会由默认的None值所替换,除非你设定了default参数值:

>>> m = re.match(r"(\d+)\.?(\d+)?", "24")
>>> m.groups()  #第二个组默认值为None(The second group defaults to None)
('24', None)
>>> m.groups('0')  #现在第二个参数的默认值为'0'(Now, the second group defaults to '0')
('24', '0')

match.groupdict(default=None)
返回一个由所有匹配上的子组组成的字典,键名为组名.default参数用于设置没有参加匹配的组的默认值;默认是None.例如:

>>> m = re.match(r"(?P<first_name>\w+) (?P<last_name>\w+)", "Malcolm Reynolds")
>>> m.groupdict()
{'first_name': 'Malcolm', 'last_name': 'Reynolds'}

match.start([group])
match.end([group])
返回由group匹配上的字符串的开始索引和结束索引;group默认为0(意味着整个被匹配的子字符串).如果group存在,但是并没有匹配上内容,则返回-1.对于一个匹配对象m,和一个匹配上内容的组g,由组g匹配上的子字符串(等于m.group(g))为:

m.string[m.start(g):m.end(g)]
注意,如果group匹配上了一个空(null)字符串,则m.start(group)等价于m.end(group).例如,m = re.search('b(c?)', 'cba')后,m.start(0)是1,m.end(0)是2,m.start(1)和m.end(1)都是2,并且m.start(2)则会抛出一个IndexError异常
*.上面之所以在只有一个括号的情况下给出了0和1两个组都不会报错,其实是因为0是一个特殊的组,那个括号其实对应的是组1,而且end的值其实比实际的位置要大1,和循环中使用列表是一样的,for i in [1,8]其实只是1,2,3,4,5,6,7并没有8

下面这个例子将会从email地址中移除remove_this:

>>> email = "tony@tiremove_thisger.net"
>>> m = re.search("remove_this", email)
>>> email[:m.start()] + email[m.end():]
'tony@tiger.net'

match.span([group])
对于一个匹配对象m(原文只写了match没有写object,但我觉得应该是match object),返回一个含有两个元素的元组(m.start(group), m.end(group)).注意,如果group没有匹配上内容,则返回的元组为(-1, -1).group默认为0,即完整(整个)匹配.

match.pos
pos值被传递到一个正则表达式对象的search()方法或match()方法中.这是RE engine在字符串中寻找匹配的开始位置

match.endpos
pos值被传递到一个正则表达式对象的search()方法或match()方法中.RE engine搜索到这就结束了(其实要时刻注意边界的问题)

match.lastindex
上一个(最后一个)匹配的捕获组的整数索引,如果没有组匹配上则值为None.例如,表达式(a)b, ((a)(b)),和((ab)),如果应用到字符串'ab'有索引lastindex == 1,当表达式(a)(b)被应用到字符串'ab',则lastindex ==2.
*.感觉这里的last应该翻译为最后一个

match.lastgroup
上一个(还是译为最后一个?)被捕获的组的名称,如果那个组没有名字,或是没有组能匹配上字符串则名字为None.

match.re
正则表达式对象,它的match()方法或search()方法产生这个匹配实例

match.string
被传递到match()或search()方法中的字符串

-----------个人见解-------------
非重叠匹配:有字符串'1234',(\d\d)+会匹配12和34而不是12 23 34,从这里去理解非重叠匹配,也可以想想两个相应的椭圆
正则表达式对象   r = re.compile('\d+')   这里的r应该叫做正则表达式对象
匹配对象 b = r.research('123')   结合着上一条来说,这里的b应该是匹配对象
正则表达式对象偏重于用r去找(其实是对正则表达式的一个封装,然后将封装后的东西赋给变量r),而匹配对象偏重于对已经找好的内容做一些操作
-----------完-------------


*****************************************************************************
                                   训练
***.现在其实最大的问题是模式中的\与原始字符串r
re.findall("()\1", "xxx")  是错误的写法
re.findall(r"()\1", "xxx") 是正确的写法
re.findall("()\\1", "xxx") 是正确的写法
为啥？这块要弄明白了也是一个小的质的变化

说明:第一遍凭想像力往出写,第二遍照着文档补充,第三遍实操补充
.
第一遍:匹配除换行符外的任意一个字符,如果加上flag=DOTALL,换行符也会被匹配上
第二遍:
^
第一遍:匹配字符串的开头
第二遍:如果加上MULTIPLINE标志除了会匹配字符串开头位置外,也会匹配字符串中每个newline后面的位置re.findall("^.","a\nb\nc\n")("*a\nb\nc\n")
              re.findall("^.", "a\nb\nc\n", re.MULTILINE)("*a\n*b\n*c\n*")
$
第一遍:匹配字符串的结尾
第二遍:1.默认情况下除了会匹配第一种情况中说的字符串结尾,还有如果字符串是以newline结尾的则也会匹配上newline前面的位置;
       2.如果加上MULTILINE标志,字符串中除了结尾的newline外，如果字符串中还有其它的newline则那些newline前面的位置也会被匹配到
       *.默认情况:"a\nb\nc*\n","a\nb\nc*"
       *.加上MULTILINE后:"a*\nb*\nc*\n", "a*\nb*\nc*"
      **.这里要注意了,我之前认为以\n结尾的字符串"a\nb\nc\n"默认情况下$会匹配两个位置,经过测试不然,如果字符串结尾是\n则默认只匹配\n前面,而'字符串的结尾位置'是不会匹配的,例re.findall(".$","a\nb\nc\n")--> ['c']
             re.findall(".$", "a\nb\nc\n", re.MULTILINE)  -->['a', 'b', 'c']
             通过结果可结,如果按我之前所想以\n结尾的字符串匹配两个位置的话得到的结果应该是['c', '\n']  和['a', 'b', 'c', '\n']
*
第一遍:匹配前面正则的零个或多个，贪婪模式
第二遍:
+
第一遍:匹配前面正则一个或多个,贪婪模式
第二遍:
?
第一遍:匹配前面正则0个或1个,贪婪模式
第二遍:
*? +? ??
第一遍:对应上面三个贪婪模式的非贪婪模式
第二遍:
{m}
第一遍:精确匹配前面正则m个
第二遍:
{m,n}
第一遍:匹配前面正则m到n个(贪不贪婪呢?)
第二遍:回答上面的问题,是贪婪的.
     1.如果指定m为一个小于0的数则忽略m
     *.实际测试当m为小于0的数则无论n为啥值得出的结果都是空的列表
     *.忽略m的形式a{,n}相当于a{0,n}
       例re.findall("a{,3}", "abc")  -->['a', '', '', '']
         re.findall("a{,3}?", "abc") -->['', '', '', '']
         语句一是用3个a,2个a,1个a,0个a的顺序依次匹配(贪婪模式，as many as possible)
         语句二是用0个a,2个a,3个a的顺序依次匹配(非贪婪模式, as fewer as possible)
       解释:要知道a{,3}与a{0,3}是等价的,所以从给定的内容可以提取出三种模式0个a(''),1个a('a'),2个a('aa'),3个a('aaa'),又因为它后面没有?故在匹配的时候是贪婪的，所以对于re.findall("a{,3}")在扫描'abc'时会先用最多的3个aaa去匹配看有没有，没有用两个a,还没有用1个a有了,然后匹配下一个,在匹配b的时候这块就不是很明白程序的实现逻辑了,因为第二个字母是b，当3个2个1个都不行的话，用''去试的时候应该这块是特殊处理了,不纠结了，有机会看源码吧
     2.如果指定n为一个无限大的数则忽略n
     *.实际测试这个无限大的数目前我也不知道是啥，查看源码里面有一个MAXREPEAT变量但是这个变量是一个定值还是一个根据情况算出来的，目前没有找到位置。实际用例的时候指定n值为一个比字符串实际长度大很多的是可以得出正确结果的，但是有一个极限大值MAXREPEAT，目前比较究结的就是我怎么知道MAXREPEAT值是多少呢
     3.n可以省略,表示匹配前面的正则最少m个(最多不限),这里注意这里忽略n了但是m和n之间的逗号要保留着,否则就变成了{m}了
{m,n}?
第一遍:匹配前面正则m到n个(是否为上个正则的非贪婪模式?)
第二遍:在上面的例子中已经覆盖了
\
第一遍:和普通字符连用组成转义序列，如果普通字符非列表中的则只匹配普通字符本身
第二遍:1.高度推荐在对含有\的字符串中使用原始字符串(r"") 想想\ \\ \\\\
       2.转义特殊字符,如*,+,?,完成对特殊字符的查找
       3.和指定的普通字符组成特殊的转义序列,如\d \s \w
       *.最后一段没看太明白，找机会再看看
[]
第一遍:它叫字符集,1.[12],[^12],[]],[1\]],[()],[1-9](是否还有其它的?)
第二遍:1.匹配-:[-a] 或 [a-] 或 [a\-b]
       2.里面的特殊字符都只表示本身如'(', '+', '*', ')'
       3.回答一中是否还有其它的?有,如字符类\w \S等,如果[]中有字符类要注意了，加不加flag参数对结果的影响是很大的
|
第一遍:可以用它分隔无数多个正则,匹配时严格按照从左到右依次,后一个表达式不可使用前一正则已匹配的字符
第二遍:举个例子:re.findall("111|[123]", "11123")  -->['111', '2', '3']
       看到了[123]明明可以匹配上整个字符串从而得到['1', '1', '1', '2', '3']但是千万要记住了|是严格尊照从左到右进行正则的匹配并且后者正则不会再重新对前者匹配上的字符进行匹配的原则
(...)
第一遍:分组,匹配的是括号里的内容,括号外的是配角,有多个()时,()之间也有依赖关系且匹配成功后是一个多元素元组
第二遍:后面可以用\number引用,如r"(123)\1"相当于r"(123)123"，但是r"(?:123)\1"就会报错因为(?:123)这种形式的组是不允许被引用的;应该还可以对匹配到的组进行检索，上面只是说的引用，但是具体的检索方法现在还不知道
(?...)
第一遍:下面()中带问号的一个引出
第二遍:这是一个扩展符号,通常扩展符号会根据问号后面的第一个字母来确定结构的意思和语法；扩展符号通常不会创建新组，但是(?P<name>...)是个例外，它会创建新组，并且还可以用\number或名称的方法引用;我是都看完一遍然后回来看这段话才明白说的是什么意思的，除了特例会创建新组外，其它的基本上都是充当绿叶的功能，真正匹配的并不是绿叶本身而是满足绿叶的红花
(?aiLmsux)
第一遍:flag的另一种表示法
第二遍:用法 re.findall("(?i)ab", "aBAbAB")  --> ['aB', 'Ab', 'AB']
            re.findall("ab(?i)", "aBAbAB")
            re.findall("a(?i)b", "aBAbAB")
       由上三条可知(?aiLmsx)是对全局起作用的位置没有关系
(?:...)
第一遍:和()的区别是在什么后不能被检索了(?)
第二遍:这一遍就明白了第一句话说的"一个非捕获版本的正则括号",为下面的不能被引用和检索埋下了伏笔。说白了就是()在匹配到内容后会将匹配到的内容给存到一个地方，以后要用的时候可以通过适当的方法取出来，而(?:...)只管匹配，匹配输出就完了并不会将匹配到的内容存起来，也就没有对匹配到的内容进行检索和引用一说
(?P<name>...)
第一遍:给分组引用多了一种引用方法-名称引用
第二遍:1. name必须是python有效的标识符
       2.在一个正则表达式中如果有多个(?P<name>...)则相互之间的name不能相同
       3.有两种引用方法，一种是通过名称形式(?P=name),一种是编号形式\number
       4.命名组有三种应用场景:
          a.在同一个模式中时:(?P=name)或\1
          b.应用在匹配对像m中时: m.group("quote") 或 m.end("quote")等
          c.在传递到re.sub()中repl参数的字符串中:\g<name>, \g<1>, \1
(?P=name)
第一遍:解释名称引用的用法
第二遍: 这个上一个例子已解释了用法
(?#...)
第一遍:正则中的注释,会被解释器忽略
第二遍:
(?=...)
第一遍:积极向前断言,字符后面是...才会匹配上,主角是其前面的字符串
第二遍:abc(?=def),只有abc后面是def才能匹配上abc  记积极住向前断言
(?!...):
第一遍:消极向前断言,字符后面不是...才会匹配上,主角依然是前面的字符串
第二遍:abc(?=def),只有abc后面不是def才能匹配上abc，记住消极向前断言
(?<=...)
第一遍:积极向后断言,字符前面是...才会匹配上,主角是后面的字符串(?),根据行为永远不会匹配到行首
第二遍:1.(?<=abc)def,只有def前面是abc才会匹配上def, 记住积极向后断言
       2.记住...必须是固定字符串，不能是一个范围
(?<!...)
第一遍:消极向后断言,字符前面不是...才会匹配上,主角是后面的字符串(?),根据行为永远不会匹配到行首
第二遍:1.(?<!=abc)def,只有def前面不是abc才能匹配上def，记住消极向后断言
       2.记住...必须是固定字符串，不能是一个范围
(?(id/name)yes-pattern|no-pattern)
第一遍:如果id/name存在则执行yes-pattern否则执行no-pattern(?)
第二遍:由于no-pattern是可选的，所以可以被忽略
**.(?)表示的只是一种意思，和在模式中的位置是没有关系的:就拿向前断言来说:"abc(?=def)"和"(?=def)abc"和"a(?=def)bc"和"ab(?=def)c"得到的结果是一样的,即它会自己将(?)两边的字符串从左到右的依序合成一个
\number
第一遍:引用组,如果首位是0,或有三位八进制数字则按八进制转义(?)
第二遍:1.[]中所有的数字转义都会被作为字符对待，如[\75]等价于[=]
       2.组引用时只接受头99个，即\1到\99(这里是从1开始而非0)
       3.如果首位是0或者是三位长度的八进制数字而是解释为拥有该八进制的字符
\A
第一遍:匹配字符串的开头位置,匹配的只是一个位置
第二遍:
\b
第一遍:匹配的是字的边界,也是匹配的一个位置,重点是字的定义!(?)
第二遍:1.匹配的是空字符串，但是只有一个字的开头或结尾
       2.字通常定义为由Unicode的字母数字下划线组成的(这里说的通常应该是指加上ASCII标志后这样说才准确，对于英文来说可能没什么但是如果掺上其它国家的文字不加ASCII标志的话就不是这样了)
       3.\b匹配的其实也是一个位置，这个位置通常是\w和\W之间，或是\w与字符串的开头或结尾之间.
       4.把小例子也写上吧: r'\bfoo\b'会匹配:'foo', 'foo.', '(foo)', 'bar foo baz'但不会匹配'foobar', 'foo3'
       5.接第2条说，空格在这里面其实又算个特例，因为无论你是否加re.ASCII，空格都会被匹配出来，只是位置不同，这里给出一个例子，好好看看，所以说别只看常规的例子要多看看特例，这样在遇到问题的时候才不会慌神
       a = '杨 强 赵 敏 A B 1'
       re.findall("\b.\b", a) --> ['杨',' ','赵',' ','敏',' ','A',' ','B',' ','1']
       re.findall("\b.\b",a,re.ASCII) --> ['A', ' ', 'B', ' ', '1']
       所以通过上面这两个小例子就可知道产东是说加上re.ASCII\b就只把字母数字下划线当成字了,否则的话这里的空格怎么解释，要不就是文档上的禅述和逻辑实现不符
       6.在一个字符范围中(字符范围应该指的是位于[]中时)，\b表示退格键字符，这是为了与python的字符串字面值兼容
\B
第一遍:匹配空字符串但是和\b相反仅仅匹配不是一个字的开头或结尾的位置
第二遍:'py\B'匹配'python', 'py3', 'py2'但是不匹配'py.', 'py!'
\d
第一遍:匹配的是Unicode中十进制数字
第二遍:1.任何[Nd]类别中的字符
       2.加上re.ASCII标志则精确匹配[0-9]
       3.对于8-bit模式就直接等价于[0-9]
\D
第一遍:与\d相反
第二遍:1.匹配任何非Unicode十六进制(非[Nd]类?)
       2.如果加上re.ASCII标志则精确等价于[^0-9](我猜[Nd]类中应该不止0-9这几个数字，如果加上该标志则[Nd]类中除了[0-9]外的其它字符也会被匹配)
\s
第一遍:匹配的是空白字符[ \t\n\r\v\f]
第二遍:1.除了[ \t\n\r\f\v]外还有其它好多字符，如许多语言在排版时强制使用的非折断空格等
       2.加上re.ASCII标志则精确的匹配[ \t\n\r\f\v]
       3.对于8-bit则只考虑ASCII字符集中的空白字符,等价于[ \t\n\r\f\v]
\S
第一遍:和\s相反
第二遍:1.匹配任何非Unicode空白字符,这正好和\s相反.
       2.如果指定re.ASCII标志则精确的等价于[^ \t\n\r\v\f](言外之意就是说Unicode字符中除了给定的这几个是空白字符还有好多其它的空白字符呢;如果不指定re.ASCII则Unicode有好多的空白字符,如果指定了,则除了[ \t\n\r\v\f]之外的字符都会被认为是非空白字符，即使你明明在Unicode里属于空白字符)
\w
第一遍:匹配Unicode字,具体字的定义是重点!(?)
第二遍:1.几乎所有语言中组成字的字符都是Unicode字字符，这不仅仅包括我们常见的[a-zA-Z0-9_]还有好多好多。
       2.如果指定了re.ASCII则精确的等价于[a-zA-Z0-9_],则因为加了ASCII标志了所以除了[a-zA-Z0-9_]原本属于Unicode的字符也不会被作为Unicode字字符对待了,最简单的例子"汉字"
       3.对于8-bit模式来说:ASCII字符集中的字母数字下划线，等价于[a-zA-Z0-9_]
\W
第一遍:和\w相反
第二遍:1.匹配非Unicode字字符，这和\w正好相反
       2.如果加上re.ASCII则精确等价于[^a-zA-z0-9_]
\Z
第一遍:匹配字符串结尾位置,匹配的只是一个位置
第二遍:
\u \U
第一遍:
第二遍: '\u'和'\U'转义序列仅仅被用于Unicode模式中,字节模式中这两个转义不会被特殊对待

**.重申重要的两点：1.Unicode某类字符有好多好多好多!
                   2.使用的时候将re.ASCII加上吧，这样范围好控制，其它不认识的字符去一边子去吧，你虽然在Unicode中和我是一类的，但是在re.ASCII中你就是外人!

**********************************************************************
6.2.2. Module Contents
re.compile(pattern, flags=0)
re.A/re.ASCII
re.DEBUG
re.I/re.IGNORECASE
re.L/re.LOCALE
re.M/re.MULTILINE
re.S/re.DOTALL
re.X/re.VERBOSE
re.search(pattern, string, flag=0)
re.match(pattern, string, flags=0)
re.fullmatch(pattern, string, flags=0)
re.split(pattern, string, maxsplit=0, flags=0)
re.findall(pattern, string, flags=0)
re.finditer(pattern, string, flags=0)
re.sub(pattern, repl, string, count=0, flags=0)
re.subn(pattern, repl, string, count=0, flags=0)
re.escape(pattern)
re.purge()
exception re.error(msg, pattern=None, pos=None)
    msg
    pattern
    pos
    lineno
    colno
6.2.3. Regular Expression Objects
regex.search(string[, pos[, endpos]])
regex.match(string[, pos[, endpos]])
regex.fullmatch(string[, pos[, endpos]])
regex.split(string, maxsplit=0)
regex.findall(string[, pos[, endpos]])
regex.finditer(string[, pos[, endpos]])
regex.sub(repl, string, count=0)
regex.subn(repl, string, count=0)
regex.flags
regex.groups
regex.groupindex
regex.pattern
6.2.4 Match Objects
match.expand(template)
match.group([group1, ...])
match.groups(default=None)
match.groupdict(default=None)
match.start([group])
match.end([group])
match.span([group])
match.pos
match.endpos
match.lastindex
match.lastgroup
match.re
match.string
6.2.5. Regular Expression Examples
