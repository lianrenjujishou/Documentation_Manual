join命令的作用:按照指定的选项将含有相同连接区域的文本合成一行并输出
*.不指定-t的情况下默认是以空白为分隔符,如果不明确指定-t则前导空白,则比较时是会被忽略掉空白的,如果指定-t则前导空白不会被忽略,即使指定-t为空白也不会忽略.
*.记住,文本文件只能是两个
*.对哪个字段进行排序之前要先将整个文本以该字段做好排序！！！(一定要排序,不然排的时候只能排一部分其余的就出错了,这样就没意了.要想明白大概的处理流程可以新建下面两个文件执行对比结果:
a:
100,1
100,2
100,3
100,4
b:
100,a,b
100,d,e
100,f,g
100,h,i
100,j,k
然后执行join -t, a b和join -t, b a看看结果,再深入一点可以再插几个首字段不同的比如200，300,分别插在不同位置,通过报错的位置和两个文件行的位置推理出大概的处理原理)
*.如果只指定了-1 -2中的一个,则肯定是和另一个文件的第一个字段比
官方说明:对于两个文本行指定字段完全相同的话,将两行合为一行输出.由空白分隔的第一字段为默认字段.当两个文件之一为-(不能两个文件参数都为-,只能有一个是),则从标准输入读取文本来替换-和指定的文本作对比.

-a FILENUM
以FILENUM指定的第几个文件(总共就两个)为准,输出以该文件为准,两个文件匹配时对指定的字段两个文件都有的肯定会输出,如果FILENUM指定的文件中某一行的字段和另一个文件没有匹配上也会将FILENUM中的该行输出,另一个文件没有匹配上的就不会输出,类似于sql中的left join,right join

-e EMPTY 看网上的例子是和-o一起连用,比如文件1中每一行只有三个字段,但你非整个-o
1.4,这时就要用EMPTY来显示了(官方解释为:用EMPTY来替换丢失的输入字段)
-i --ignore-case
对要比较的字段不区分大小写(感觉不区分的意思都是预处理时将字母都先给转成大写或小写再比,即不区分指的是有个预处理的过程),输出的结果按照给出的文件顺序输出,比如说两个文本都用第一个字段比,a的第一个字段是小写的c,b的第一个字段是大写的C,则join
-i a b 输出的时候连接有两个文本信息的行上第一个字段是小写的c.

-j FIELD 比较文件1和文件2的第几个字段(join -j 2 a b:意思是比较a,b两个文本行的第二个字段,完全相同则连接输出;等价于join -1 2 -2 2 a b)

-1 FIELD 用第一个文件的指定字段和第二个文件的第一个字段比较
-2 FIELD 用第二个文件的指定字段和第一个文件的第一个字段比较

-v FILENUM 类似于-a FILENUM,但-v输出的数据只包含FILENUM指定的文件中没匹配上的

--nocheck-order 不检查需要对比的字段是否已排序
--check-order 检查需要对比的字段是否已排序(这个应该是默认加上去的参数)
-z --zero-terminated 以NUL作为行的结尾而不是换行(该参数在centos6.5没有,debian8有)

-o
以FILENUM.FIELD的形式输出具体要的是哪个文件中文本的哪个字段,可以指定多个字段,字段间用逗号或空白隔开;还可以是0,如果是0则仅仅不重复输出所有匹配上的键(在debian8中还有另外一种用法将-o的参数设置为auto则此时输出的字段数完全由每个文件的第一行决定,无论第一行是否被匹配上)

-t CHAR 设置文本行中的字段分隔符

--header
它的作用只限定于两个文件的第一行,无论两个文本的第一行是否匹配,都按匹配输出(而且输出比较有意思,第一个文件的第一行全部输出(如果是有-1
-2这样的参数,第一个文件第一行也是全输出只不过参数后的位置字段跑到第一位了),第二个文件第一行第一个字段不输出其余输出)对于header给个例子吧:
文件a:
10,2,5,6,7
1,2,3
6,7,8,9

文件b:
7,x,y
1,a,b
6,c,d
命令:join -t, --nocheck-order --header a b
     join -t, --nocheck-order --header b a
     join -t, --nocheck-order --header -1 2 a b
看看都有什么输出,其实--header对第一行的匹配和正常匹配一样,正常匹配时显示的顺序是:比较的字段,文件1剩余的部分,文件2剩余的部分
就拿a,b的第一行来说,如果加上--header参数的话系统就假设a中的10,2,5,6,7和b中的7匹配上了,所以如果a是文件1,b是文件2的话输出为10,2,5,6,7,x,y
##.多看看多悟吧
