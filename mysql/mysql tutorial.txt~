教程说明:
本教程的目的是教你如何利用mysql客户端创建数据库及如何做一些简单的查询.mysql是一个可交互的程序,我们利用它可以和mysql服务端进行通信.mysql可以执行批处理文件.
本章讲述了关于设置和使用数据库的完整过程,但讲的比较浅,对于某些内容更详细的说明可以查看官方手册相关部分.
可以通过在命令行下输入 mysql --help 看一下mysql都提供了哪些选项.
******************
4.1 如何与Mysql服务器连接及如何断开连接
******************
4.2 输入查询语句
******************
4.3 创建及使用数据库
******************
4.4 获取数据库及库中表的信息
******************
4.5 如何执行批处理文件(官翻为:在批处理模式中使用Mysql)
******************
4.6 常用查询语句示例
******************
4.7 如何在Apache中使用mysql

#################################################################################
4.1 如何与Mysql服务器连接及如何断开连接

a(登录).通常要连接mysql服务器需要三个参数,即用户名,密码,主机名(这里的用户名和密码是mysql里建的用户和密码而非系统的,主机名是用来连接远程主机用的)。对于这三个参数可以这样理解:我们通过'主机名'找到我们具体要连接若大互联网中的哪一台机器上的Mysql服务,然后输入该台主机上mysql服务器创建的用户名及密码作为登录依据.
登录命令为:mysql -h host -u user -p[password]
*.其中host换成具体的主机名(其实是ip),user换成mysql中建立的用户名,password是用户名所对应的密码
*.再有password是被[]括起来的,所以可写可不写,这里的可写可不写的意思是说可以不直接写在-p后面,即直接写mysql
-h 192.168.0.1 -u root -p,回车,之后会提示输入密码的,这样安全一些.直接写在-p后不是不可以,linux系统里有命令可以读取你在命令行里输入的历史命令,如果我们直接写成mysql -h 192.168.0.1 -u root -p123456这样的话,别人读取历史命令就可以直接看到咱们的密码了,不安全.
*.其实这里面-h host,-u user可以写成-hhost,-uuser即选项与参数之间不是必须有(改之前为:不是有必有)空格,需要再次声明的是-p参数还不一样,-p参数是一定不能有空格,-p a这里的a就不是密码了,而是数据库名称

b(登录).输入mysql -h192.168.0.1 -uroot -p(或mysql -h 192.168.0.1 -u root
-p123456),回车之后输密码,之后出现 Mysql> 提示符表示连接成功,你现在就可以输入SQL语句了(访问本地的mysql服务器一般不用加-h参数,数据库会默认加上的).

c(登录).在登录的时候可能会遇到各种错误,可以参考:http://dev.mysql.com/doc/refman/5.7/en/common-errors.html

d(登录).可能通过设置允许运行在本地的用户作为匿名用户访问mysql数据库(为什么是作为匿名用户呢,因为mysql数据库中没有建立这条记录,这只是一个便于登录本机mysql数据库的机制),这样我们只需在装有mysql服务器的机器终端上运行mysql回车后直接就可进入控制台了

e(退出):quit(不区分大小写),\q(必须小写),ctrl+d(有的系统,像debian8中也可ctrl+c退出)
----------------------------------------------------------------------------------
4.2 输入查询语句

a.查询mysql服务器软件的版本号 select version();
b.查询mysql服务器软件所在主机的当前时间 select current_date;
c.可能一次查询多个信息,只需将各信息用英文状态下的逗号隔开 select version(),current_date;
d.根据abc可以看出以下几点：
	1.一个普通的查询是由sql语句和结尾的分号组成(一开始写的时候最容易忽略sql语句结尾的分号)
	2.当你输入语句并回车后,mysql客户端会将语句发给mysql服务端执行,然后返回结果,然后再将主动权交给 mysql> 提示符
	3.返回的结果是表格形式的,通常第一行信息是我们在excel中常见的表头,从第二行开始是数据.一般我们在查询的时候会
	  指定要查询表的哪些列,这里的表头就是我们指定的列名称,如果查询的是一个表达式而不是表中某一个具体的列,则此处
	  表头显示的就是表达式
	4.mysql服务器给我们返回的信息中包含,此次查询共返回了多少行,耗时多少,从这些信息中我们可以粗略的知道该服务器的性能.这里说的粗略是因为该时间不是指的mysql服务器处理查
	  的时间,它可能还包括服务器加载信息,网络延迟等的时间
e.重要的一点:mysql终端对字母的大小写是不敏感的!
f.可将mysql终端作为计算器使用,方法是 select expression,expression,…;
g.可以在一行写多条语句,需要注意的就是多条语句要用分号隔开.需要说明一点,一行上执行多条语句返回的是多个表,而不是因为写在一行上就都放在一个表里
h.接g来说,也可以将一条长语句分在几行写,最后以分号结尾就好(这里说下原理,mysql客户端以是否遇到分号来确定你的语句是否输入完成,而不是以换行,当你在多行写一条语句时,mysql客户端会
一行一行的收集信息,但此时并不发给服务端,一旦遇到分号,收集结束,将信息交给服务端执行),单词不能给拆开!
i.接g,h说,还可以在多行输入多条语句,不过不怎么实用,还是以分号区分两条语句,既使最后一条语句没写完也没关系,mysql客户端会先将完整的句子发给服务端,服用端返回信息后,会返给你一个>,因为你的最后一条还没写完嘛,如果最后一条语句是以分号结尾,则返回的就是mysql>了
j.对于多行语句来说,>符号是我们的朋友,因为当我们遇到>的时候就知道该语句还没结束,mysql客户端还在等待着什么
k.重要!如果我们在写多行语句的时候,突然不想写了,可以通过在>输入\c来结束该条多行语句的输入,提示符又会变为mysql>来等待我们输入新的语句
l.总结一下你可能遇到的提示符种类,以及这些提示符都表示什么意思:
	1. mysql> 等待你输入新的语句
	2. -> 等待你输入多行语句的下一行
	3. '> 等待着字符串输入的结束(即等待着另外一个单引号来结可该字符串的输入)
	4. " 意义同3,只当过是等待着另一个双引号来结束字符串
	5. `> 等待着识别符的输入完成(这里的识别符举个例子来说,比如'表中的列名',更深的对于如何设置识别符再学)
	6. /*> 等待着注释的输入完成
m.在l中的这些未完成的提示符后输入quit,\c啥的没用,因为在这些提示符下，mysql客户端不特殊解释quit和\c,所以明白这些提示符的含义非常重要!
----------------------------------------------------------------------------------
4.3 创建及使用数据库

上一章说的查询语句到现在来说其实还没有意义呢,因为到目前为止我们还不会建数据库,所以谈如何写查询语句没意义,这节就来说说如何利用mysql客户端创建并使用数据库
a.查看当前服务器上都已经创建好了哪些数据库(之前写的是:服务器)  show databases;(一般默认都会有mysql这个库,里面的内容控制着用户的访问权限),可以控制show的使用权限,后面遇到再说吧
b.有好多数据库呢,我们在输入查询语句之前必须使用use命令指定我们要用哪个(数据库) 'use 数据库'  *.需要注意的是use命令和quit命令一样不需要在后面加分号就可以正常执行,但是use指令只能写在一行!
c.一般情况下存在mysql服务器中的数据库只要你有账号密码就能任意改动(在不设置权限的情况下),为了避免多人共用的时候别人改动你建的库可以设置权限只有指定的user在指定的ip下才能访问该库 grant all on 数据库名.* to 'mysql_user'@'ip' 
小标题:创建并且选择要操作的数据库
	a.创建一个名为menagerie的数据库: create database menagerie; *.数据库名称和表名称对大小写敏感,这一点要注意,像平时在mysql>下输入的指令和表中的字段名对大小写是不敏感的
	b.mysql中还有一个'当前数据库'的概念,所以想用哪个数据库之前要先 use 数据库 更详细的已在上面的b中有详细的说明
	c.每次访问mysql数据库的时候都要use一下我们要操作的数据库,还有一种方法就是在登录的时候直接指定要访问的数据库,上面已提过 'mysql -h192.168.0.1 -uroot -p 数据库名'
	d.可以用select database();来查看当前正在使用的数据库
小标题:在数据库中建表
	a.在上一节讲了如何创建一个新数据库,但数据库创建完之后里面是空的,啥也没有(通过show tables;可查看表),所以我们还需要在库里建表
	b.创建表 'create table 表名 (字段名1 字段1类型, 字段2 字段2类型,…,字段n 字段n类型)'  需要注意的有两点,一是将mysql支持的类型都弄清楚了并知道该类型一般什么时候用,二就根           据实际情况确定具体该字段要用啥类型,一定要为字段设定好类型否则后期变动会很麻烦,这块看似简单的一个类型其实也很有学问的,设置好了为后期省好大事
	c.在建表的时候涉及到年龄的最好设置为date类型,而不是其它类型的几岁之类的,因为mysql提供了date相关的运算函数,你可以随时知道它当前多少岁,但如果你设置为像字符串类型的,写上他          8岁,如果我要问你他现在多少岁,你肯定说不清楚,你还要手动的查一些像登记日期或问其它人就比较麻烦了
	d.如果前期设置表的时候没弄好,比如某个字段的数据类型已不满足现有数据的长度了,需要改字段的数据类型,这里可以用alter语句进行修改
	e.查看当前选中的数据库中有哪些表 'show tables;'
	f.查看当前数据库中dog表的结构 'describe dog;' 在不知道表中字段名或是字段类型的情况下可以用该命令查看
小标题:向表中插入数据
	a.头两节讲了如何创建库及如何在库中创建表,这节该讲向表中插入数据了
	b.插入数据有两种方式,单条的话用insert插入好一些 'insert into 表名[字段名] values(字段值)' 如果表后没有字段名的话则字段值要将所有的字段值都写全,如果字段名指定了几个字段,
          则字段值处只要写这几个字段的值就可以,如果不知道具体值的字段可以设置为NULL,该记录的其它字段值会被自动设置值;多条的话用'load data',因为在一个表中每一条记录的结构是一样的          ,所以可以利用文本文档批量导入,在文档中一行是一条记录,记录的字段间用tab隔开即可,用\N来表示NULL 'load data local infile '绝对路径' into table 表名',如果该文件是在windows          下创建的由于批量导入时默认是按Linux下的行结束符为标准的即\n,而windows是以\r\n来结束行的,所以语句要写成
          load data local infile '文件绝对路径' into table 表名 lines terminated by '\r\n';
小标题:从表中检索数据
----------------------------------------------------------------------------------
4.4 获取数据库及库中表的信息
最常用的格式是 'select 列名s from 表名 where 条件' 
解释为:从'表名'中选取满足'条件'的'列',你看我在列名后加了s，就说明你可以以逗号间隔选取多列,设置为*的话是选取所有列
小小标题:选取所有的数据
	a.选取表中所有的数据其实就是指将列设置为*(*表示所有列) select * from 表名;
	b.如果在利用insert into和load data local进行导入后,一般我们都应该select查看一下,如果某个字段值有错误的话我们有两种方法来改正
	  法一(清空重导):利用'delete from 表名;'将表清空,然后在批量文本中改正过来,最后执行'load data local infile '文件绝对路径' into table 表名'
	  法二(update语句):如果只是单条错误的话用update语句是最方便的 update pet set birth='1989-08-31' where name = 'bowser'
小小标题:选取指定行
	a.这一小节其实就是where关键字的应用
	b.字段中的数据对大小写不敏感 where a='abc'和where a='aBc'搜出的结果是一样的
	c.OR和AND可以一起用,但AND的优先级大于OR,所以如果一起用的时候最好用括号精确的分下组
小小标题:选取指定列
	a.这一小节主要讲的是列的位置不是*了,而是具体的某一或某几列
	b.如果选择的某一列中有重复的数据可以用'distinct 列'来去重
小小标题:排序行
	a.讲了利用order by进行排序,默认order by对大小写是不敏感的,如果想大小写敏感排序可以用order by binary
	b.order by默认是升级排列可以用'order by 列名 desc'来对指定列进行降序排列
	c.可以对多列进行排序,多列以逗号分隔(最主要的是多列排序其实有分组的概念在里面在下面的d中解释)例如'order by a,b des'(这里desc只响应b而不影响a)
	d.对于多列排序的举例说明:
	  A B C
	  a 1 10
	  b 1 10
	  a 2 10
	  b 2 10
	  c 1 10
	  d 1 10
	  假如有一个表table,有这么三列,分别是A列,B列,C列
	  那么对于select * from table order by A,B desc;这一句处理流程是这样的:
	  首先处理的是紧跟在order by后的列,也就是A列,因其后面没有东西故按默认的升序排列,得到一个临时表为:
	  a 1 10
	  a 2 10
	  b 1 10
	  b 2 10
	  c 1 10
	  d 1 10
	  然后对得到的这个临时表执行order by 后第二个列的排序即B
	  desc,这一块是重点,第二次按照B
	  desc进行排的时候是要考虑到第一次对A的排序的,因为你排的时候不能只考虑B自身,而忽略之前A的排序,如果忽略的话之前A的排序就没意义了!所以是在A排序的基础上再对B列进行一个           降序,什么叫在A的基础上呢,我的理解就是要引入一个分组的概念,即在进行A的升序排序后将A中完全相同的值会在逻辑上分为一组,不完全相同的各自成组,而对B的降序排列完全是对A中           有两个或两个以上完全相同值的行进行的排序,而对那些在A列中没有相同值的那些记录B desc对它们是完全没有作用的!
	  a 2 10 a 1 10
	  b 2 10
	  b 1 10
	  c 1 10
	  d 1 10
	  得到的结果是上面这个,其实处理B desc时只影响了两个a和两个b,对c和d就没起作用,因为c 和d没有相同的值
小小标题:日期类型字段记算
	  a.mysql客户端提供了几个用于处理date类型数据的函数可以用来计算年龄及提取部分日期
	  b.timestampdiff(result expressed,小日期,大日期)函数,用来计算两小日期的差值,result expressed是对于计算结果你想要的部分,比方说year,month,day等
	  c.对于像死亡日期这类字段一般都初始为NULL值,检测某个字段是或不是NULL用'where field is[ not] null'
	  d.year(),month(),dayofmonth(),括号里面是date类型的值或date类型的字段来提取相应的年份,月份,该月的第几天,还可以有dayofyear()等函数
	  e.date_add(日期,interval number year/month/day)解释为在日期的基础上再加上number个year/month/day,官网给的例子是month(date_add(curdate(),interval 1 month)),该函数对	       于获取将来指定间隔的日期很有用
	  f.mod(a,b)函数是a%b的值,mod(month(curdate()),12)+1就可以得到下个月是几月,因为month(curdate())得到1-12,1-12除以10得到的余数是从0-11
小小标题:和NULL值一起工作
	a.如果记录中某个字段的值目前是'未知的'可以先将该字段设为NULL
	b.用is null 或 is not null 来判断is前面的值是某为null,返回的是布尔值
	c.运算符号和null连用没有意义,因为任何运算符号和null一起运算都会返回null,如1=null 1>null 1<null 1<>null通通返回的是null.突然想起之前判断空值的时候用'字段<>null'的时候得           不到正确的结果,现在看来是因为判断字段是否为null只能用is null 或is not null而不用用'字段<>null',因为'值 运算符 null'反回的永远是null
	d.0和null表示false,其它值表示true
	e.在group by分组时,NULL和其它值一样也会被分为一组
	f.在order by中,如果升序的话NULL会被排在第一位,如果是降序的话,NULL会被排在最后一位
	g.从e和f中大概能看出我的推断是正确的,就是order by对多列排序时是有分组概念的
	h.还有重要的一点,在设置表时有的字段要求是not null的,也就是非空,这时就要注意了空字符串''和0是可以向这些字段中插入的,所以你要记住null的意思是'没有值',而0和''都是值.所以关          键还要明白null到底表示是啥意思.对于这一点可以用select 0 is null, 0 is not null, '' is null, '' is not null看看返回值,到底服务器认为0和''是否为空
小小标题:模式匹配
	a.正常情况下mysql下的模式匹配是 ‘select 字段 from 表 where 字段 like/not like '正则表达式'’
	b.接a,但是正常情况下用like或not like做关键字的话正则中的元字符只有_与%两个,其中_表示任意一个字符,%表示任意个字符(包括0个),例如'b%'表示以b开始后面接任意个字符,'%fy'表示           以fy结尾前面是任意个字符,'%w%'表示任意字符接w再接任意字符,'_____'表示有五个字符
	c.mysql中的正则还有许多扩展的元字符,但如果用这些扩展元字符的话关键字就不能用like或not like了,要用 regexp(或rlike)和not regexp(或not rlike),下面看一下扩展的元字符都有哪           些:
		. 匹配任何单个字符
		[] 匹配[]中的任何一个字符,如[abc]则匹配a或b或c,也可以在[]中用-连接一个范围,如[a-z]匹配26个字母,[1-9]匹配9个数字
		* 匹配任意个前面的字符,如'x*'匹配0个x到无数个x,'[0-9]*'匹配任意数量的数字,'.*'匹配所有
		^ 匹配开始位置
		$ 匹配结尾位置
		{n} 前面字符重复n次 'x{5}'匹配5个连续的x
	d.接c说,regexp模式可以匹配字符串的任意位置,而like模式匹配必须将被测试值全部匹配上才行,对于'test'来说,无论是't%'还是'%t'还是'%t%'最后都是完整的匹配上'test'才算成功,而rex          exp来说'.'表示只要'test'中含有一个字符就算匹配成功,所以regexp比like要灵活
	e.使用扩展正则 regexp '^b'表示任何以b开头的字符串,regexp 'fy$'表示任何以fy结尾的字符串,'w' 匹配字符串中含有w.其中mysql扩展正则就和平时接触的sed vim vi awk中的差不多了,           功能已非常强大
	f.如果扩展正则也想匹配的时候大小写敏感可以用rexexp binary '正则',此时正则中是大写就匹配大写是小写就匹配小写,当然like也可以用like binary '表达式',只不过有局限性'表达式'           必须要完整的匹配上字符串的值
小小标题:显示共选择了多少行
	a.主要是用count(*)查看指定条件的记录共有多少行
	b.count(*)经常与group by一起用于'分组统计'
	c.下面看个分组的例子:
	  A B C
	  1 2 3
	  1 2 3
	  2 3 1
	  1 3 2
	  2 3 1
	  2 1 3
	  2 3 1
	  上面是文件test的内容,我们现在进行分组,例1: select A from test group A;得到的结果是:
	  A
	  1
	  2
	  解释:因为该句只是单纯的对A进行排序然后将A输出,如果此时句子变成select A,B from test group A;执行会出错,可以看出实际上是要求多输出一列B,为什么就出错呢,可以从例子中看              一下,对A排序后A列只剩下1和2,但是1对应的B列的值是不同的有2有3,所以我输出A列1的时候B列我到底要输啥呢?同理对A列排序后除了上面说的1还有一个2,对这个2也是一样的,对应A列               的2,B列有不同的值1和3,故我输出2的时候如果你也选择要将B列输出的话B列的值我是输出1还是3呢?所以会出错!
	  例2: select A,B from test group A,B;得到的结果是:
	  A B C
	  1 2 3
	  1 3 2
	  2 3 1
	  2 1 3
	  解释:这个算是对例1的说明,可以得出一个结论就是如果后面用group by进行分组了,你对谁进行分的组select的时候就可以选谁(这里的谁指的是表中的列,如果不是表中的列如count(*)函
	  数是没有问题的),没在group by后面的列是不能够select的否则会出错(道理在例1中已讲)!接下来说处理过程:
	  首先处理的是紧跟着group by的列,也就是列A,得到一个临时表为:
	  A B
	  1 2
	  1 2
	  1 3
	  2 3
	  2 3
	  2 1
	  2 3
	  此时可以看出A列已排好,然后就是对group by后的第二个列进行分组,也就是B列,下面讲的是理解分组的核心知识点,就是对B进行分组时一定要考虑之前排好的列A,也就是说对B列的分组               其实是在A列分组的基础上进行的,再说白一点,对多列分组可以理解为'对已经分组的组进行分组',此例中,分好的组指的是A列中的1大组和2大组,下面说具体的处理流程:
	  首先将1大组提取出来即:
	  1 2
	  1 2
	  1 3
	  然后对2进行分组,第一行的B列是2,第2行的B列也是2,因为A都是1所以可以合并,第3行B列是3没有相同的单为一组,输出为:
	  1 2
	  1 3
	  其次将2大组提取出来即:
	  2 3
	  2 3
	  2 1
	  2 3
	  对B列进行分组,可以看出有两个不一样的,故输出为:
	  2 3
	  2 1
	  最后对1大组和2大组进行整合,输出的就是:
	  1 2
	  1 3
	  2 3
	  2 1
	  说明如果原文件还有一个行是3 1 2
	  则这一列只参与A列的分组,不参与B列的分组,因为A列分组后没有与3相同的行,所以也就谈不上B列的分组了,记住B是在A已经分好的组中进行二次分组;如果group by A,B后还有一个C,则对C组          的排序则是建立在B分组的基础上,就像周扒皮一样,一层一层的扒,还有最重要的一点就是如果select中有统计函数count()的话,它统计的是所有列都分好组后的值
	d.当SET sql_mode = 'ONLY_FULL_GROUP_BY'时,如果select中有count()函数,则select选中的其它列就一定要出现在group by后面,否则会报错;当SET sql_mode = ''时,
          直接'select 列,count(*) from 表'就可以,但是此时会将该列所有值认为是相同的(即将表中所有记录认为是一组),而且处理程序会自动从你选择的列找一个值作为组的代表输出
小小标题:多表联查
	a.主要讲的是利用inner join on 来多表联查
	b.inner join可以利用别名进行同表连查例 from pet as p1 inner join pet as p2
----------------------------------------------------------------------------------
4.4 获取数据库及库中表的信息
a.显示mysql服务器上现有的数据库: show database;
b.显示当前选中(使用)的数据库名称: select database(); 如果执行此语句前没有use过则返回的是null
c.显示当前使用的数据库中的表: show tables;
d.查看指定表的结构: describe 表名;
其中field为字段名,type为字段类型,null为是否允许为null,key表示字段是否被索引,default指定默认值,extra显示额外的信息如如果一个字段被设为auto_increment则extra处显示的就是auto_increment.
e.查看表结构,比describe显示的信息全一些(给出了创建表的完整语句,知道用的是什么引擎,默认字符集是什么): show create table 表名;
f.显示表索引: show index from 表名;
----------------------------------------------------------------------------------
4.5 如何执行批处理文件(官翻为:在批处理模式中使用Mysql)
a.在文本中写好mysql语句,然后在shell>下执行 'mysql -uroot -p < 文件名' 需要注意的是如果文件不在当前路径下要写全文件名
b.-v是显示处理的详细信息,如果输出的信息太多还可以 'mysql -uroot -p < 文件名 | more' 来分屏显示处理的过程信息
c.将处理信息输出到文件 'mysql -uroot -p < 文件名 >outfile'
d.在批处理模式下输出的信息是精简的,说白了就是表格没了,如果想输出有表格的(官翻为交互格式)则加上参数-t
e.在mysql>下也可以执行批处理文件,命令是'source filename' or '\. filename' 
f.如果执行批处理文件时遇到错误也可以继续执行的话需要加上--force参数
g.windows下运行含有特殊字符的脚本(特殊字符应该指的就是和linux下文本中不同的换行符了吧):mysql -e "文件名"    *.注意该文件是否在当前路径下,如果不是要用绝对路径
h.前面不也讲过嘛,通过设置可以直接mysql就进入mysql控制终端了(利用本地正在运行的账户作为mysql中的匿名用户登录),这种情况下直接 'mysql<文件名' 就能执行了
----------------------------------------------------------------------------------
4.6 常用查询语句示例
小小标题:找出列数据的最大值
	a.select max(字段名) from 表名;   可以给max()加个别名,这条语句会输出某一列的最大值
小小标题:找出某一列数据最大值在哪一行
	a.法一(利用从句): select article, dealer, price from shop where price=(select max(price) from shop);  注意price=后面是一个从句,这里要注意了,从句输出的内容一定要是唯           一值否则会报错
	 法二(利用left join):select s1.article, s1.dealer, s1.price from shop
s1 left join shop s2 on s1.price < s2.price where s2.article is null;
可参考:http://bbs.csdn.net/topics/350254101?page=1  11楼贴子看看on和where一起连用时啥时候一样啥时候不一样
	法三(利用order by desc和limit):select article, dealer, price from shop order by price desc limit 1;
小小标题:找出每组列的最大值
	a.这个没啥说的看例子吧: select article, max(price) as price from shop group by article;
小小标题:获取同一列中同一组中的最大行
	a.法一:select article, dealer, price from shop s1 where price=(select max(s2.price) from shop s2 where s1.article = s2.article);
	b.法二:select s1.article, dealer, s1.price from shop s1 join (select article, max(price) as price from shop group by article) as s2 on s1.article = s2.article and                s1.price = s2.price;
	c.法三:select s1.article, s1.dealer, s1.price from shop s1 left join s2 on s1.article = s2.article and s1.price < s2.price where s2.article is null;
	d.其中法二和法三我可以理解,法一有点不理解,想明白法一中是如何处理的(我的理解是s1按顺序将article值传给子句,子句将得到的max(s2.price)进行去重,然后主句中的条件就变成了
          price in(经过去重的max(s2.price))),如果是详s1.article传一个值select就输出一行的话我理解不了;无论在哪块应该都有分组或去重这一步
小小标题:使用用户自定义变量
	a.先利用select语句给变量赋值: select @min_price:=MIN(price),@max_price:=MAX(price) from shop;  或 set @min_price=(select min(price) from shop);
	  然后就可以在以后的查询中使用了:select article from shop where price=@min_price;
小小标题:使用外键
小小标题:Searching on Two Keys
小小标题:计算每天的访问量
	a.select year,month,bit_count(bit_or(1<<day)) as days from t1 group byyear,month;   这里两个bit_函数很巧妙(有网友用子句也实现了,不过少知道效率:select year, month, 
          count(0) from (select year, month, day,count(0) from t1 group by year, month, day) as tmp group by year, month;)
小小标题:便用自增关键字auto_increment
