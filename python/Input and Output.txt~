7.输入和输出
有几种不同的方式可以用来表示程序的输出;数据可以用人类可读的形式被打印出来,或者是将数据写入一个文件留着以后用.这章要讨论的可能存在的数据输入输出情况.

7.1.比较奇特的格式化输出
目前为止,我们已经遇到了两种写值的方式:expression语句和print()函数.(第三种方式是用文件对像的write()方法;基本的输出文件可以参考sys.stdout.Library
Reference一章有更多关于输入输出的信息)

通常情况下你想要对输出的格式有更多的控制,而不仅限于打印被空格分隔的值.这里有两种方式可以来格式化你的输出;第一种方式,是自己处理所有的字符串;用字符串的分片和连接操作你可以创建任何你能想到的布局(或说设计).字符串类型有一些方法对于填充字符串到一个给定的列宽度是很有用的;稍后将会对上述做相一个讨论.第二种方式就是使用字符串的format()方法(str.format()).

string模块包含了一个Template类,这个Template类还提供了另一种方式用来将值代入字符串(这个没啥,有点类似于python的re模块的操作,不解释了看一个例子吧就明白了:
>>> from string import Template
>>> s = Template('$who likes $what')
>>> s. substitute(who='tim', what='kung pao')
'tim likes kung pao')

还剩一个问题了,这个问题肯定是:我们如何将任何一个类型的值转化为字符串类型呢?幸运的是,python已经提供了将任何类型的值转为字符串的方式,即:将任何类型的值传给repr()函数或str()函数.

str()函数打算返回人类可读性非常好的值,当repr()函数打算要创建能被解释器理解的表现(或者如果没有等价的语法的话,会强制性的给出一个SyntaxError错误).对于人类使用没有特定表现的对象,str()的返回值和repr()返回值是一样的.许多像数字或者列表及字典这样的结构,使用str()和使用repr()函数的表现是一样的.字符串比较特殊,使用str()和repr()函数的表现不同.(这一段中间句没翻译好,暂时就先看按最后三个句号的意思理解吧)

举例:
>>> s = 'Hello, world.'
>>> str(s)
'Hello, world.'
>>> repr(s)
"'Hello, world.'"
>>> str(1/7)
'0.14285714285714285'
>>> x = 10 * 3.25
>>> y = 200 * 200
>>> x = 'The value of x is ' + repr(x) + ', and y is ' + repr(y) + '...'
The value of x is 32.5, and y is 40000...
>>> #添加字符串引号和反斜线的repr()字符串函数
... hello = 'hello, world\n'
>>> hellos = repr(hello)
>>> print(hellos)
'hello, world\n'	#从输出结果也可以看出,print()函数只识别一层字符串中的像\n这种特殊字符
>>> #repr()的参数可以是Python中的任何对象,对于下面这个例子str()也适用,根据它官方只说了repr()的参数可以是任何对象而没有说str()，是不是要说repr()要比str()强大呢?后期如真遇到这样的例子再说吧,目前看差不多
... repr((x, y, ('spam', 'eggs')))
"(32.5, 40000, ('spam', 'eggs'))"

下面的例子是用两种方式来写一个平方表和一个立方表:
>>> for x in range(1, 11):
...	print(repr(x).rjust(2), repr(x*x).rjust(3), end=' ')
...	#注意上一行'end'的使用它的作用是设置一行结束后的结束字符,默认是换行,上一行设置的是一个空格
...	print(repr(x*x*x).rjust(4))
...	
1	1	1
2	4	8
3	9	27
4	16	64
5	25	125
6	36	216
7	49	343
8	64	512
9	81	729
10	100	1000
>>> #注意上面每行中三个元素的宽度我没有按照代码要求的打而是都用的tab,按理说第一个元素占2个字符,第二个占3个字符,第三个占4个字符都是右对齐

>>> for x in range(1, 11):
...	print('{0:2d} {1:3d} {2:4d}'.format(x, x*x, x*x*x))
...		
1	1	1
2	4	8
3	9	27
4	16	64
5	25	125
6	36	216
7	49	343
8	64	512
9	81	729
10	100	1000
>>> #同样这个输出也没有按照规定的占位宽度输出,而是统一用的tab
(注意,在第一个例子中,print()函数打印的时候,在两列数据之间加了一个空格:这也是print()函数的一个特性,在两个输出的参数之间会自动添加一个空格)

这个例子演示了字符串的rjust()方法的使用,rjust()方法会给字符串一个指定的宽度,当字符串的长度小于给定的宽度时在左侧用空格补齐.当然有右对齐就有相应的左对齐str.ljust和中间对齐str.center().这些字符串的方法不会向字符串写入任何内容,它们仅仅返回一个新的字符串.如果字符串的长度超出了给定的宽度也不会被截短,而是将原字符串返回;返回的字符串较长的话会影响列布局的美观,但这样也要好于你将字符串截短返回,不截短影响的只是美观,但你截短后输出的东西就不是原字符串了(如果你真觉得字符串太长只需要返回指定部分的字符串,可以使用序列数据类型都支持的分片操作,如x.ljust(n)[:n])

还有另外一种方法str.zfill(),用来在数字字符串前面填充0.这个函数明白+符号和-符号:
>>> '12'.zfill(5)
'00012'
>>> '-3.14'.zifill(7)
'-003.14'
>>> '3.14159265359'.zfill(5)
'3.14159265359' #这个给定字符串占位宽为5,但实际宽度超过了5,故原样返回

str.format()的基本用法类似于这样:
>>> print('We are the {} who say "{}!"'.format('knights', 'Ni'))
We are the knights who say "Ni!"

花括号和花括号中的的字符被传递到str.format()方法中的对象所替换.花括号中的数字是用来参考到时替换的时候到底是用format()中的第几个对象参数来替换.
>>> print('{0} and {1}'.format('spam', 'eggs'))
spam and eggs
>>> print('{1} and {0}'.format('spam', 'eggs'))
eggs and spam

如果关键字参数(即所谓的键值对)也被用于str.format()方法中,则字符串中花括号中就不再是空或数字而是关键字,根据这个关键字到时用相应的值来替换:
>>> print('This {food} is {adjective}'.format(food='spam', adjective='absolutely horrible.'))
This spam is absolutely horrible.

位置参数和关键字参数可以随意结合使用:
>>> print('The story of {0}, {1}, and {other}'.format('Bill', 'Manfred', other='Georg'))
The story of Bill, Manfred, and Georg.

'!a'(转为ascii码), '!s'(转化为str())and'!r'(转化为repr())可以用来在格式化之前转换值
>>> import math
>>> print('The value of PI is approximately {}'.format(math.pi))
The value of PI is approximately 3.14159265359.
>>> print('The value of PI is approximately {!r}'.format(math.pi))
The value of PI is approximately 3.141592653589793.

一个可选的冒号':'和格式化指定符可以根在区域宽的后面.这又提高了对格式化值的灵活度.下面这个例子是将Pi保留到小数点三位:
>>> import math
>>> print('The value of PI is approximately {0:.3f}'.format(math.pi))
>>> #注意{0:.3f}表示将format()中的第1个对象传给它,并将该对象保留三位小数

如果:后面跟的是一个整数,则该整数表示的该对象占的位宽的最小值(就是说你最少得给这个对象分配这么宽的位置),这种种况对制作一个漂亮的表非常有帮助:
>>> table = {'Sjoerd': 4127, 'Jack': 5098, 'Dcab': 7678}
>>> for name, phone in table.items():
...	print('{0:10} ==> {1:10d}'.format(name, phone))
...	
Jack	==>	4098
Dcab	==>	7678
Sjoerd  ==>	4127
>>>上面的输出没有按照代码给定的10个宽度输出

如果你真的有一个非常长的字符串,你又不想将字符串进行分开格式化,那么你可以通过参考名称来格式化而不是参考位置.我们可以能过将字典中的键以一定格式放入花括中,然后通过引用该键去字典中取出相应的值进行替换:
>>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 8637678}
>>> print('Jack: {0[Jack]:d}; Sjoerd: {0[Sjoerd]:d};Dcab: {0[Dcab]:d}'.format(**table))
Jack: 4098; Sjoerd: 4127; Dcab: 8637678

我们还可以通过将压包字典的形式(用**符)来通过关键字替换:
>>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 8637678}
>>> print('Jack: {Jack:d};Sjoerd:{Sjoerd:d};Dcab:{Dcab:d}'.format(**table))

这面这种方法和内建的vars()函数一起使用作用非常好,vars()会返回包含所有本地变量的一个字典.

完整的字符串格式化内容(str.format())可以看一下Format String Syntax

7.1.1.老版本的字符串格式化
%符号也可以用于字符串格式化.它会用右边的参数才替换左边的参数(说准确些应该是用右边的参数值去替换左边字符串中的参数,这个替换很像sprintf()函数,该函数记得应该是只赋值不输出的),然后将替换后的字符串返回:
>>> import math
>>> print('The value of PI is approximately %5.3f.' % math.pi)
The value of PI is approximately 3.142.
>>>#对于这个例子的处理可以分成两步,第一步是math.pi替换%5.3f,然后将替换后的字符串替换掉print()中的参数;第二步,print()函数将字符串输出.

更多关于老式替换(%)的内容,可以参看printf-style String Formatting这部分内容.

7.2.读写文件
open()函数会返回一个文件对象,open()函数最普遍的用法是和两个参数一起用,第一个参数是文件名filename,第二个参数是你打开文件的模式mode(是读呀写呀还是其它的),open(filename,mode).
>>> f = open('workfile', 'w')	#这时面的f是一个文件对象,以后操作f就相当于直接操作对象了,和调用sql时的游标是一个意思

第一个参数是包含文件名的字什串.第二个参数是另一个包含描述文件通过什么方式被使用的字符串.当文件仅仅是被读取,可将模式设为'r',当仅仅是要写入文件,则将模式设为'w'(需要注意的是如果要写的这个文件不存在,python会创建一个,如果此时存该文件的路径下有一个同名的文件,则这个同名的文件会被覆盖掉),如果是想向文件尾追加内容,可以将模式设为'a';被追加到文件的数据会被自动添加到文件尾.如果你即有对文件的读取需求,又有写入需求,可以将模式将为'r+'.模式参数是可选的;如果忽略模式参数默认是'r'.(注意分号表示上一句还没说完,即分号前后说的是一件事!)

通常情况下文件是使用text模式打开的,也就是说,你可以用指定的编码从这个文件里面读取或写入字符串.如果你没有指定编码,则你读写的时候具体默认的是什么编码是和平台有关的(可以看open()函数一节,看看什么平台默认用的是什么编码).如果将'b'追加到模式尾,则表示用二进制的方式打开文件:此时我们读取或写入数据是以字节对象的形式.文本以外的文件都应该用二进制模式打开.

在文本模式,当读取字符串的时候,默认是将指定平台相关的行结尾符都转化为\n(这个行结尾符和平台是有关的,在Unix中默认行都是以\n结尾的,在windows平台下文本行默认都是以\r\n结尾的,我们其实要的就是Unix平台下的结尾符).当在文本模式下我们做写操作时,我们再将\n给替换成指定平台的行结尾符.像这种先都将行结尾符给替换为\n,完事后再将所有的\n都替换为平台指定的结尾符对于文本模式来说是非常好的一种做法,但如果用文本模式打开二进制文件可能会损坏像JPEG和EXE这样的二进制文件.所以要小心对二进制文件的读写.

7.2.1.文件对象的方法
这章中下面的例子,假设我们已经有了一个名为f的文件对象已经被创建.

为了读取文件内容,调用f.read(size),read()函数可以从文件中读取size大小的数据并将这些数据作为字符串或是字节对象返回.size是一个可选的数值型参数.当size被忽略或为负数时,会读取整个文件的内容并返回;如果文件的大小是你系统内存的2倍大,就会出问题了(它这里的2倍大应该只是为了表达只要文件的大小大于你系统的内存,就会出问题).如果你设置了size的大小,则每次最多返回size大小的字节.如果已经达到文件尾了,则f.read()将会返回一个空字符串(比如一个字符串有1到10十个字符,咱们f.size(1),这样第一次返回1,第二次返回2,第十次返回10,第十一及以后都返回空字符串)
>>> f.read()
'This is the entire file.\n'
>>>f.read()
''

f.readline()函数可以从一个文件中每次读取一行;并且读取的行都是以新行符(\n)结尾(这个应该从读取到输出中间还有一步就是判断结尾是不是\n如果不是则替换为\n,因为我在windows下readline()后结尾的也是\n,按理说windows下应该是\r\n才对),如果读取的是最后一行的话可能结尾不会有\n.这样使得返回值很清楚明白;如果f.readline()返回了一个空字符串,表示已经到了文件尾了,当我们在一行什么都没写就直接回车的话,readline()读取到这一行输出的仅仅是'\n'字符串.
>>> f.readline()
'This is the first line of the file.\n'
>>> f.readline()
'Second line of the file\n'
>>> f.readline()
''

我们可以通过循环遍历文件对象的方式来读取行.这种做法的优点是节约内存,快速,代码简单:
>>> for line in f:
...	print(line, end='')
...
This is the first line of the file.
Second line of the fie

如果你想要将文件所有的行读取并放入列表中,你可以用list(f)或f.readlines().

f.write(string)会将内容写入到文件,并返回写入的字符数量.
>>> f.write('This is a test\n')
15

如果想要将非字符串值写入文件,需要将该值先转化为字符串类型:
>>> value =('the answer', 42)
>>> s = str(value)
>>> f.write(s)
18

f.tell()会返回一个整数,该整数在二进制模式下表示的是文件开头到当前位置的字符数,在文本模式下,表示的是一个难懂的数(之所以说是难懂的数是因为比如在一个都是汉字的文本中,编码不同一个汉字占有的字符数也不同,而且通常一个汉字都不是由一个字符组成的,咱们估且说一个汉字是由两个字符组成,那么如果这个字符给出的是3(通常和下面要讲的f.seek()结合使用)表示什么呢,一半字?)

为了改变文件对象的位置,可以使用f.seek(offset,
from_what).这个位置是从from_what位置加上offset得到的;from_what有三个值,文件开始位置是0,1表示的是当前位置,2表示的是文件的结尾位置.from_what参数可以被忽略,默认是0,即用文件的开始位置作为参考点.
>>> f = open('workfile', 'rb+')
>>> f.write(b'0123456789abcdef')
16
>>> f.seek(5)	#到文件的第6个字节
b'5'
>>> f.seek(-3,2)	#倒数第3个字节
13
>>> f.read(1)
b'd'

在文本模式中(模式中没有'b'的时候),仅仅允许以文件的开头为参考点进行seek(有一个例外,即seek到文件尾seek(0,2))并且只有0或f.tell()返回的值是有效值.其它任何offset都会产生未被定义的行为.

当你操作完一个文件的时候,可以调用f.close()来关闭它来释放一些被该文件占用的系统资源.在调用f.close()之后,再尝试着去使用文件对象f的话会失败.

>>> f.close()
>>> f.read()
Trackbase (most recent call last):
  File "stdin", line 1, in ?
ValueError: I/O operation on closed file

当我们处理一个文件的时候使用关键字with是一个很好的做法.with的优点是它可以在语句块完成后自动关闭文件,即使正在使用时出现了异常,它也会将文件对象关闭.而且它的语句块要比做同等操作的try-finally块小.
>>> with open('workfile', 'r') as f:
...	read_data = f.read()
>>> f.closed
True

文件对象除了上面提到的方法外还有一些额外的方法,例如isatty()方法和truncate()方法,只不过这两种方法的使用频率比较低;想要学习关于文件对象的完整版可以参考Library
Reference.

7.2.2.用json格式保存结构化数据
我们容易的从一个文件读取信息或是向一个文件中写入信息.但是对于数字信息就要麻烦一点,因为read()函数只返回字符串,所以想要得到数字类型的信息必须还要将返回的字符串传给像int()这样的函数,int()等函数会将字符串类型的'123'转化为数值类型的123.当你想要保存更复杂的数据类型,如嵌套列表和字典,则靠手动解析和序列化会变得非常麻烦.

不是让用户不停的写代码、调试代码来保存复杂的数据类型到文件中,Python允许你使用流行的数据交换格式JSON(JavaScript Object Notation).叫做json的标准模块可以将Python数据分层,并且将它们转化为字符串表示法;这个过程被称为序列化.从字符串表示法进行数据重构叫做反序列化.在序列化与反序列化之间,表示对象的字符串可以被存储进一个文件或是数据中,或是通过网络发送到已经建立连接的远程机器上.

Note JSON格式通常被用于现代的程序上为了允许数据交换.许多程序员都已经对它非常熟悉了,这使得,json对于互操作性是一个不错的选择.

如果你有一个对象x,你可以用简单的一行代码来看一下它的JSON字符串表示法:
>>> json.dumps([1, 'simple', 'list'])
'[1, "simple", "list"]'

另一个dumps()函数的变体叫做dump(),dump()函数仅仅序列化对象到一个文本文件.因此,如果f是用于写入的文本对象,我们可以这样做:
json.dump(x, f)

我们可以再次对对象进行解码,如果f是一个读模式的文本对象:
x = json.load(f)

这种简单的序列化技术可以处理列表和字典,但是想要序列化任意的类实例在json中我们还需要一些额外的操作.json模块的参考包括了对于这方面的解释.

See also   pickle-pickle模块
和JSON相反,pickle模块是一个允许序列化任何复杂的Python对象的协议.同样的它只针对于Python不能与用其它语言语的应用进行沟通.默认情况下pickle协议也是不安全的:从一个不被信任的源进行反序列化pickle数据可能会执行任意代码,如果源文件是一个被技术精湛的攻击者精巧制作的文件.
