9.类
和其它程序设计语言相比,Python的类机制给类添加了很少的语法和语义.Python的类机制是C++的类机制和Modula-3类机制的混合体(再和上一句结合起来是不是python类机制就是在这个混合体的基础上又添加了一点Python独有的语法和语义).Python类提供了面象对象编程的所有基本功能:类继承机制允许多基类,一个派生类能够覆盖它的基类或是类提供的任何方法,并且一个方法可以以本民的名字调用基类的方法.对象可以包含任意数量和任意类型的数据.类作为模块是正确的,因类带有Python的动态性质:作为它们在运行时被创建,并且它们在创建后可以被进一步的修改.

在C++术语中,类成员(包括数据成员)通常是公共的(public,即谁都可以访问)(除了下面提到的Private Variables),并且所有的成员函数都是虚拟的.像在Modula-3中,没有速记法来从它的方法中参考对象的成员:方法函数明确的用第一个参数来表示通过调用隐式提供的对象.像在Smalltalk中,类本身就是对象.这为导入和重命名提供了语义.不像C++和Modula-3,内建的类型可以被用作用户扩展的基类.同样,和C++相似的是,大多数有特殊语法的操作符(数学运算符,加下标等)可以为了类别实例而被重新定义.

(缺乏大家都接受的术语来讨论类,我偶尔会利用使用Smalltalk和C++中的条目.我会用Modula-3的条目,因为它的面象对象的语义与C++相比的话和Python更接近,但是我希望有少数人已经听说过它了)

9.1.关于名称和对象的单词
对象可以有多个个性的名称(多个名称后的括号里还有一个in multiple scopes)被绑定到同一个对象上.就像我们在其它语言中了解的别名一样.这通常不会在我们第一次浏览Python的时候被领会,并且当我们处理不变的基本类型(数值,字符串,元组)时,可以被安全的忽略.然而,别名可能会对调用可变对象(列表、字典、及其它可变类型)的Python代码的语义可能会有意外的影响.这通常是对程序有好处的,因为别名在某些方面类似于指针.例如,传递一个对象是便宜的(这里便宜的应该理解为耗费小),因为仅仅实现了对一个指针的传递;如果一个函数修改了一个作为被传递的参数的对象,则调用者会发现这个改变--这就消除了要有两个不同参数的需要,在Pascal中通常是要传递两个不同参数的.

9.2.Python范围和命名空间
在介绍类之前,我首先不得不告诉你关于Python的范围规则的一些事情.类定义和名称空间玩了一些特别巧录的技巧,并且为了完全明发年了什么你需要明白范围和名称空间是如何工作的.另外说一句,这个主题的知识对于任何高级的Python程序员都是有用的.

让我们以一些定义作为开始.

一个名称空间就是一个从名称到对象的映射(map).大多数的名称空间当前被作为Python字典实现,但是无论如何它都不是显而易见的(除了性能),并且它在将来可能会被改变.名称空间的例子是:内建名称的集合(包括函数,例如abs(),和内建的异常名称);模块中的全局名称;在一个函数调用中的本地名称.在某种意义上一个对象的属性对象的集合也形成了一个名称空间.对于名称空间我们要知道的重要事情是不同的名称空间中的名字是完全没有关系的;例如,两个不同的模块可能都定义了一个函数maximize而不被混淆--模块的用户使用相应的函数时必须要将模块的名称作为前缀.

顺便提一下,我在跟着点的名称后面使用属性--例如,在表达式z.real中,real是对象z的一个属性.严格来讲,在模块中对名称的参考就是对属性的参考:在表达式modname.funcname,modename是一个模块对象,funcname是modname的一个属性.在这种情况下,就在定义在模块中的属性和全局名称之间发生了明确的映射:它们共享同相同的名称空间!

属性可能是只读的或是可写入的.在后一种情况中,我们可以给属性赋值.模块的属性是可读的:你可以写作modname.theanswer =42.可写的属性也可以用del语句进行删除.例如, del modname.the_answer将会从名为modname的模块中移除the_answer这个属性.

在不同时候创建的空称空间有不同的生命期.包括内建名称的名称空间是当Python解释器启动时被创建的,该名称空间是永远不会被删除的(除非你关了Python解释器).一个模块的全局名称空间是当模块的定义被读入的时候被创建的;通常,模块名称空间会持续到解释器退出.通过Python解释器的顶级调用来执行的语句(这些语句或者是从脚本读入的,或是从标准输入读入的)被认为是被称为__main__模块的一部分,因此它们有它们自己的名称空间.(内建的名称实际上也是在模块中;内建名称所在的模块被称为builtins.)

一个函数的本地名称空间是在函数被调用时创建的,并且这个名称空间是在函数返回(returns)或者是抛出(raise)了一个在函数内没被处理的异常时被删除.(实际上,为了描述实际发生了什么忘记会是一种不错的方式)当然,递归递用,每一个都有它们自己的本地名称空间.

一个作用域(scope)是Python程序中的一块文本区域,在这个区域可以直接访问名称空间.这里的"直接访问"意味着对尝试在名称空间中找到的名字的无限制参考("Directly accessible" here means that an unqualified reference to a name attempts to find the name in the namespace.)

尽管scope(作用域or范围or其它?)是被静态决定的,但我们可以动态地使用它.在执行的任何时间,都至少有三个内嵌的范围,它们的空称空间可以被直接访问:
  最里面包含本地名称的范围最先被搜索
  任何封闭的函数(包含非本地的,但是也非全局名称(指nonlocal?))内的范围,以最近的封闭范围开始被搜索(这里面enclosing要是理解为封闭的函数有点不大合适,我记得上几章中某处我提到过,enclosing function指的是父函数或者是再高一层的函数,即该名词是用在有嵌套的函数里面的,如果B是在A函数中,则enclsing function指的就是A函数)
  靠近最后的或叫倒数第二的(next-to-last)范围包含当前模块的全局名称
  最外层范围(最后被搜索)是包含内建名字的名称空间
	
如果一个名称被声明为global,则所有对变量的参考和赋值都会直接转到包含该模块的全局名称的中间范围.为了重新绑定发现在最里层范围外部的变量,可以使用nonlocal语句;如果没有声明nonlocal,则这些变量是只读的(尝试着写这样的变量将仅仅会在最内层范围创建一个新的本地变量,舍弃被改变的相同名称的外部变量).

通常,本地范围参考当前函数的本地名称.在函数之外,本地范围参考相同的名称空间作为全局范围:模块的名称空间.然而/但是类定义放置了另外一个名称空间在本地范围.

了解范围是由原文原定的这一点非常重要:定义在模块中的一个函数的全局范围就是那个模块的名称空间,无论这个函数是从哪或是从哪个别名调用的.另一方面,目前的名称搜索是动态的,是在运行时进行的--然而,语言定义正在朝着静态的名称解析进化,在编译时,因此不用依赖动态的名称解析!(实际上,本地的变量早已被静态的决定了)

Python有一个怪癖--如果没有global语句生效--给名称赋值总是进入最里面的范围.赋值不会拷贝数据--它们仅仅是将名称绑定到对象.删除也是一样的:del
x将会从本地范围的参考名称空间移除x的绑定.实际上,引进新名称的所有操作都使和了本地范围:尤其是import语句和函数定义在本地范围绑定了模块或是函数名.

global语句可以被用来表示全局范围中的特殊变量,并且global语句应该被绑定在这;nonlocal语句表示父函数范围中的特殊变量并且nonlocal语句应该被绑定在这.

9.2.1.范围和名称空间例子
下面这个例子演示了如何参考不同的范围和名称空间,global和nonlocal是如何影响变量绑定的:
def scope_test():
  def do_local():
    spam = "local spam"
  def do_nonlocal():
    nonlocal spam
    spam = "nonlocal spam"
  def do_global():
    global spam
    spam = "global spam"
  spam = "test spam"
  do_local()
  print("After local assignment:", spam)
  do_nonlocal()
  print("After nonlocal assignment:", spam )
  do_global()
  print("After global assignment:", spam)
scope_test()
print("In global scope", spam)
上面代码输出如下:
After local assignment: test spam
After nonlocal assignment: nonlocal spam
After global assignment: nonlocal spam
In global scope: global spam
注意本地赋值怎么没有改变spam的scope_test绑定.nonlocal赋值改变了spam的scope_test绑定,global赋值改变了模块级别的绑定.

你还可以看到在global赋值之前,没有为spam过早的绑定.

9.3.初识类
类引入了很少的新语法,三个新对象类型,和一些新的语义.

9.3.1.如何定义一个类
定义一个类最简单的形式如下:
class Classname:
  <state,emt-1>
  .
  .
  .
  <statement-N>
类的定义和函数的定义类似(def语句),一定要在它们产生任何影响之前被执行(应该是说在用到类中的内容之前,就要执行这个类,相当于你只有将东西都加载进来了,我后面再用你这里面的东西时才不会报错说没有啥的).(你可以放心地将一个类定义放在if语句的一个分支中,或是放在一个函数中)

实际上,一个类定义中的语句通常是函数定义,但是也允许有其它的语句,有时是有用的--我们晚些时候会回过头来讨论这个问题.一个类中的函数定义通常会有一个特殊形式的参数列表,通过方法的调用约定进行口述--同样关于这个问题也稍后进行解释.

当一个定义义被键入,就会创建一个新的名称空间,并且这个空间被用作本地范围--因此,所有对本地变量的赋值都会进入到这个新的名称空间.尤其是,函数定义在这绑定新函数的名字.

当一个类定义一般会被遗弃(到达结尾了),一个类对象会被创建,这是一个基本的包装器围绕着被类定义创建的名称空间的内容;我们会在下一节学到更多关于类对象的内容.原始的本地范围(实际上是在类定义被键入之前的那个)被恢复,并且类对象被绑定在这为了在类定义头中给定的类名称(在这个例子中是ClassName)

9.3.2.类对象
类对象支持两种类型的操作:属性参考和实例化.

属性参考使用最标准的语法用于Python中所有的对象参考:obj.name.有效的属性名称是类中名称空间里的所有名称,当类对象被创建时.因此,如果类定义像下面这样:
class MyClass:
  """A simple example class"""
  i = 12345
  def f(self):
    return 'hello world'
然后MyClass.i和MyClass.f是有效的属性引用,分别返回一个整数和一个函数对象.类属性也可以被赋值.因此你可以给MyClass.i赋值.__doc__也是一个有效的属性,返回属于类的文档字符串:"A simple example class".

类实例化使用函数符号.仅仅是假装类对象是一个无参数的函数,这个函数返回一个类的新实例.例如(假设上面例子中的类已存在):
x = MyClass()
这就创建了类的一个新的实例并且将这个对象赋值给本地变量x.

实例化操作("调用"一个对象)创建了一个空的对象.许多的类想要用自定义一个指定的初始化状态的实例来创建对象.因此一个类可能定义一个名为__init__()的特殊方法,像下面:
def __init__():
  self.data = []
当一个类定义一个__init__()方法时,类定义会自动为新创建的类实例调用__init__()方法.因此在这个例子中,一个新的,实始化的实例可以被包含,通过:
x = MyClass()
当然,__init__()方法为了更灵活可能会有参数.在这个例子中,被给万类实例操作符的参数被传递到__init__()方法中.例如,
>>> class Complex:
...  def __init__(self, realpart, imagpart):
...    self.r = realpart
...    self.i = imagpart
...
>>> x = Complex(3.0, -4.5)
>>> x.r, x.i
(3.0, -4.5)

9.3.3.实例对象
现在我们能用实例对象做什么?实例对象唯一明白的操作就是属性参考.有两种类型的有效属性名,数据属性和方法.

数据属性相当于Smalltalk中的"实例变量",和C++中的"数据成员".数据属性不需被声明;像本地变量,他们第一次被赋值时就存在了.例如,如果x是上面被创建的MyClass的实例,则下面这段代码将会打印值16,没有遗留一个痕迹:
x.counter = 1
while x.counter <10:
  x.counter = x.counter * 2
print(x.counter)
del x.counter
另一种类型的实例属性参考是一个方法.一个方法是一个"属于"一个对象的函数.(在Python中,方法对于类实例不是唯一的:其它对象类型也可以有方法,例如,列表对象有append，insert，remove,sort,等等方法.然而,在下面的讨论中,我们说明的术语'方法'仅仅是指类实例对象的方法,除非明确的说明了其它的方法外.)

一个实例对象的有效方法名依靠于它的类.通过定义,所有函数对象类的属性都定义了类实例的相应方法.因此在我们的例子中,x.f是一个有效的方法参考,因为MyClass.f是一个函数,但是x.i不是,因为MyClass.i不是.但是x.f和MyClass.f不是相同的东西--x.f是一个方法对象,不是一个函数对象.

9.3.4.方法对象
通常,一个方法在被绑定之后调用:
x.f()
在MyClass例子中,这将会返回字符串'hello world'.然而,立刻就调用一个方法不是必须的:x.f是一个方法对象,并且可以被存储起来以后调用.例如
xf = x.f
while True:
  print(xf())
这个例子也会打印'hello world'字符串

当一个方法被调用时具体发生了什么呢?你可能已经注意到上面的x.f()被调用时是没有参数的,虽然在类中的f()函数有一个参数(self).那么这个参数发生了什么呢?当一个函数个参数才能被调用,但是调用时却没有给它参数Python肯定会抛出一个异常--即使这个参数实际上并没什么用...

实例上,你可能已经猜到答案了:对于方法特殊的事情就是对象被传递作为函数的第一个参数.在我们的例子中,我们调用x.f()精确的答于MyClass.f(x).通常,用n个参数的列表来调用一个方法等价于用类名调用相应的函数，并且函数的参数列表前插入引用方法的对象.

如果你还不明白方法是如何工作的,看一下实现(指的应该是输出结果)可能会更清晰一些.当一个实例属性被参考(这个实例属性指的不是数据属性),它的类将会被搜索.如果名字表示一个有效的类属性(该类属性是一个函数对象),一个方法对象会通过打包指向的实例对象被创建并且函数对象仅仅在一个抽象的对象是才会被一起发现:这就是方法对象.当方法对象被用一个参数列表调用时,一个新的参数列表被从这个实例对象和参数列表构建,函数对象会被用新的参数列表调用.

9.3.5.类和实例变量
一般而言,实例变量支持每一个实例的数据唯一性,类变量支持属性和方法共享通过类的所有实例:
class Dog:
  kind = 'canine' #类变量被所有的实例共享
  def __init__():
    self.name = name  #实例变量对于每一个实例是唯一的
>>> d = Dog('Fido')
>>> e = Dog('Buddy')
>>>d.kind #被所有的dogs共享
'canine'
>>> e.kind  #被所有的dogs共享
'canine'
>>>d.name   #对于d是唯一的
'Fido'
>>> e.name  #对于e是唯一的
'Buddy'
正如我们在A Word About Name and
Objects,共享数据可能会有意外的影响在调用可变对像(如列表和字典)时.例如,下面代码中的非常巧妙的列表应该被用作一个类变量因为仅仅一个单独的列表会被所有的Dog实例共享:
class Dog:
  trick = []  #类变量的错误用法
  def __init__(self, name):
    self.name = name
  def add_trick(self, trick):
    self.tricks.append(trick)
>>> d = Dog('Fido')
>>> e = Dog('Buddy')
>>> d.add_trick('roll over')
>>> e.add_trick('play dead')
>>> d.tricks  #不希望被所有的dogs共享
['roll over', 'play dead']
该类的正确设计应该是使用一个实例变量来代替:
class Dog:
  def __init__(self, name):
    self.name = name
    self.tricks = []  #为每一个dog都创建一个空列表
  def add_trick(self, trick):
    self.tricks.append(trick)
>>> d = Dog('Fido')
>>> e = Dog('Buddy')
>>> d.add_trick('roll over')
>>> e.add_trick('play dead')
>>> d.tricks
['roll over']
>>> e.tricks
['play dead']
***看到这好像是说类中的变量是对所有实例都共享的,但是类中的方法里面的变量就是对每个实例都是唯一的,还拿内存来说,类中的变量就是一块固定的地方,每个实例写东西的时候都是往那一个地方写,但是方法中的变量就不同了,我们每定义一个不同的类实例就会单独的在内存中找一块地方存放这个变量,即声明十个变量,程序会在内存中声明十个不同的地方来存放类中的方法里面的变量,所以说不互相影响.

9.4.随机标注
数据属性覆盖方法属性用相同的名称(类中有一个函数名为func,在该func函数里还有一个func变量,当第一次引用x.func()的时候是没问题的,但再次用x.func()就会报错,因为第一次引用func的时候引入了func变量,再次引用的时候不知道是从里向外的原则还是怎么的,x.func()就会出错提示说func是一个字符串);为了避免意外的名称冲突,这种冲突在大的程序中是很难找的bug,使用某些类型的约定来最小化冲突的机会是很明智的.可能的约定包括对于方法的名称要用大写的,对数据属性名称前要加一个小的唯一的字符串作为前缀(可能仅仅是一个下划线),或者是方法名使用动词,数据属性使用名词.

数据属性可能会通过方法来参考也可能通过对象的普通用户('client')来参考.换句话说,类对于实现纯粹的抽象数据类型是没有用的.实际上,在Python中没有什么能够强制数据隐藏--数据隐藏都是基于协议的.(另一方面，python实现,用C写的,能够完整的隐藏实现的细节和对一个对象的访问控制,如果需要的话;这对于在Python中扩展C是很有用的.)

客户产应该小心使用数据属性--客户端可能会混淆通过在它们的数据属性上盖戳的方法维护的不变量.注意客户端可能会在不影响方法有效性的前提下,添加它们对于一个实例对象它们自己的数据属性,只要名字冲突被避免了--再次强调,命名约定想好了,可以减少后期不少的头疼问题.

对于函数内部的数据属性(或者其它方法!)的参考没有速记的方法.我发现这实际上是增加了方法的可读性:当浏览一个方法时不可能使本地变量和实例变量相混淆.

通常,一个方法中第一个被调用的参数被称为self.这只不过是一个约定:名字self对于Python来说完全没有什么特殊的含义.注意,然而,不遵守这个协议你的代码可能对其它的程序员来说可读性要差一些,写一个类浏览器程序需要依靠这样一个协议这一点是我们应该想到的.

类属性的任何函数对象定义了一个函数或是那个类的实例.函数定义被包装在类定义中不是必须的:将一个函数对象赋给一个类中的本地变量也是可以的.例如:
#被定义在类外面的函数
def f1(self, x, y):
  return min(x, x+y)
class C:
  f =f1
  def g(self):
    return 'hello world'
  h = g
现在f,g和h都是参考了函数对象类C中的属性,因此他们都是C实例中的方法--h精确的等于g.注意这样做通常容易使读程序的人产生混淆.

方法可能会调用其它的方法通过使用self参数中的方法属性:
class Bag:
  def __init__(self):
    self.data = []
  def add(self, x):
    self.data.append(x)
  def addtwice(self, x):
    self.add(x)
    self.add(x)
方法可能会用相同的方法参考全局名称作为普通的函数.和方法有关的全局范围是包含了方法定义的模块.(类从硅烷夯实了用作全局范围)当一个稀少的遇到一个好的原因对于使用全局数据在一个方法中,有许多全局范围使用合理的方法:首先,被导入到全局范围的函数和模块可能被方法使用,as
well as functions and classes defined in
it.通常,定义在这个全局范围中的是包含方法的类自身,下一节我们会找到一此好的原因对于为什么一个方法会想要参考它自己的类.

每一个值都是一个对像,因此每个值都有一个类(也可被称为它的类型).被作为object.__class__存储.

9.5.继承
当然,一门语言的功能如果不支持继承则配不上"class"的称号.派生类的语法定义如下:
class DerivedClassName(BaseClassName):
  <statement-1>
  .
  .
  .
  <statement-N>
BaseClassName必须被定义在一个包含了派生类定义的范围中.代替基本的类名,其它任意的表达式都是允许的.这是有用的,例如,当基类被定义在另外一个模块中时:
class DerivedClassName(modname.BaseClassName):
派生类定义的执行和基类的执行是一致的.当类对象被构建,基类被会想起.这对于解析属性参考是有用的:如果一个请求的属性在类中没有被发现,则会继续在它的基类中搜索看是否有这个属性.这条规则被递归应用如果基类也是从其它的类派生来的话.(即如果有十层深的继承,我现在位于最里面,我此时请求一个属性,如果最里面没有这个属性而这十层又分别属于继承关系的话,会从里向外一层一层的找直到找到最外一层)

派生类的实例化没有什么特殊的:DervivedClassName()就创建了一个类的新实例.方法参考会做如下解析:相应的类属性被搜索,如果没有找到的话继续向上找,方法参考是有效的,如果这产生了一个函数对象.

派生类可能会覆盖它们基类的方法.因为方法没有特权当调用相同对象的另一个方法时,一个方法调用在另一个基类中的相同方法可能会结束派生类方法的调用从而覆盖它.(对于C++程序员来说,Python中的所有方法实际上都是虚拟的)

在派生类中的重新定义的方法可能实际上是想扩展而不仅仅是替换基类中的同名方法.有一种简单的方法可以直接调用基类的方法:仅仅是调用BaseClassName.methodname(self, arguments).这有时对于客户端来说也是有用的.(注意仅仅是基类在全局范围内被作为BaseClassName访问时,它才工作.)

Python有两个内建的函数对继承是有效的:
  使用isinstance()函数来检查一个实例类型:isinstance(obj, int)是true如果obj.__class__是int型的或者是一些类派生于整型
  使用issubclass()来检查类的继承:issubclass(bool, int)是true因为bool是int的一个子类.然而,issubclass(float, int)是false因为float不是int的一个子类.

9.5.1.多继承
Python也支持多继承的形式.一个有多个基类的类定义如下:
class DerivedClassName(Base1, Base2, Base3):
  <statement-1>
  .
  .
  .
  <statement-N>
大多数的目的,在这个最简单的例子中,你能认为属性的搜索是依照深度优先的原则搜索父类,从左到右,在同一个类中不会搜索两次这里相同的类表示同一次的重叠.因此,如果一个对象没有在DerivedClassName中发现,它将会从Base1中搜索,然后递归Base1的基类,如果在Base1中没有发现，则会继续从Base2中搜索,等等.

实际上,它比那个稍复杂一些;方法的解析顺序动态的更改为对super()函数的支持合作调用.这个方法在其它多继承的语言中被知道是作为call-next-method,多继承语言比单继承语言中的super更强大.

动态排序是必须的因为多继承中的所有情况都显示出一个或多个关联性非常强的关系(在这些类中至少有一个父类可以被最底端的类访问通过多路径).举例来说,所有的类都是继承自object,因此多继承的任何一种情况都会提供超过一种路径到达object.为了保持多次访问基类,动态的算法使得搜索序顺在某种方式上是线性化的,保存指定在每一个类中的从左到右的顺序,调用每个父类仅一次,是单调的(意味着一个类可以是没有影响前面顺序的父类的子类).这些属性使得用多继承来设计可靠的和可扩展的类成为可能.详情可看http://www.python.org/download/releases/2.3/mro/.

9.6.私有变量
在Python中不存在只有对象自己内部可以访问外部访问不了的"私有"变量.然而,大多数的Python代码都遵守一个约定:有下滑线前缀的名字应该被作为API的非公共部分(不论它是一个函数,一个方法还是一个数据成员).这应该被作为一个实现细节如有更改不另行通知.

因为有一个有效的用例对于私有类成员(就是为了避免和子类中定义的名称冲突),对这样的机制的支持是有限制的,称为名字整编.任何形成__spam这样的识别符(至少两个前缀的下滑线,最多一个下划拖尾)都会被_classname__spam所替换,其中classname是当前类的类名加上两个下滑线前缀.这样命名不考虑识别符的句法外置,只要它在定的定义中发生了.

名称整编对于让子类在没有破坏内部(intraclass)方法调用的前提下覆盖方法.例如:
class Mapping:
  def __init__(self, interable):
    self.items_list = []
    self.__update(iterable)
  def update(self, iterable):
    for item in iterable:
      self.items_list.append(item)
  __update = update #普通的update()方法的私有化复制

class MappingSubclass(Mapping):
  def update(self, keys, values):
    #为update()方法提供新的签名
    #但是不破坏__init__()方法
    for item in zip(keys, values):
      self.items_list.append(item)
注意整编规则被设计主要是用来避免事故的;我们访问或是修改一个所谓的私有变量一直是可以的.这种整编规则在特殊情况下是有用的,例如在调试器中.

注意被传递到exec()或是eval()中的代码不将调用的类名作为当前类;这类似于global语句产生的影响,这个影响同也也限制被编译的字节代码在一起.同样的约可还适用于getattr(),setattr(),delattr(),并且当直接参考__dict__时也是一样的.

9.7.差别和结束
有时让一个数据类型和Pascal的"record"或是C中的"struct"类似还是很有用的,将几个被命名的数据项绑捆在一起.一个空类定义将会做的很漂亮:
class Employee:
  pass
john = Employee() #创建一个空的employee记录
#添充记录的区域
john.name = 'John Doe'
john.dept = 'computer lab'
john.salary = 1000
一个Python代码片段期望一个特殊的抽象数据类型可以被传递到一个类中,什么样的类呢,就是这个类模拟数据类型的方法,例如,如果你有一个从一个文件对象格式化一些数据的函数,你可以用read()方法和readline()方法定义一个类,这两个方法从一个字符串缓存中获得数据,并且将它作为一个参数传递.

实例方法对象也有属性:m.__self__是带有m()方法的实例对象,并且m.__func__就是与方法相一致的函数对方.

9.8.异常也是类
用户定义的异常也被认为是类.使用这个机制,我们可能创建可扩展层级的异常.

下面是两个raise语句的有效格式(语义的):
raise Class
raise Instance
在第一种形式中,Class必须是type的一个实例或者一个类从它派生的实例.第一种格式是一个简称:
raise Class()
在一个except从句中的一个类和一个异常是相兼容的如果它是相同的类或者是其中的一个基类(但不是另外一个方向around--列出一个派生类的一个except从句是不和基类相兼容的).例如,下面的代码将会按顺序打印B,C,D:
class B(Exception):
  pass
class C(B):
  pass
class D(C):
  pass
for cls in [B, C, D]:
  try:
    raise cls()
  except D:
    print("D")
  except C:
    print("C")
  except B:
    print("B")
注意如果except从句是颠倒的(最开始是except B),它将会打印B,B,B--第一个匹配的except被触发.
***.看到上面这段话和例子大概明白了，说的是如果raise抛出的异常(异常其实就是一个类)，和except后面要捕获的异常是同一个或者except后面要捕获的异常是raise抛出异常的基类则该except后面的语句就会被执行，并不一定说抛出的异常和捕获的异常一定完全是同一个类。但是如果except后面要捕获的异常只是raise异常的一个派生类则该不会执行该except下的语句；另外再说一句，感觉如果有10000个except的话应该也是一个一个向下查找

当一个错误信息被打印为了一个未被处理的异常,这个异常的类名被打印,然后是一个冒号和一个空格,最后实例被转换为一个字符串用内建的str()函数.

9.9.迭代器
到目前为止你已经注意到大多数的容器对象可以被遍历通过for语句:
for element in [1, 2, 3]:
  print(element)
for element in (1, 2, 3):
  print(element)
for key in {'one':1, 'two':2}:
  print(key)
for char in "123":
  print(char)
for line in open("myfile.txt"):
  print(line, end='')
这样的访问类型是清晰并且方便的.迭代器的使用遍及整个Python.for语句在容器对象中调用了iter()函数.这个函数返回一个迭代器对象,这个迭代器对象定义了__next__()方法,这个方法一次访问容器中的一个元素.当容器中没有剩余的元素时,__next__()函数会抛出一个StopInteration的异常,通过抛出这个异常来告诉for循环该结束了.你可以使用内建的next()函数来调用__next__()方法;下面这个例子演示了它是如何工作的:
>>> s = 'abc'
>>> it = iter(s)
>>> it
<iterator object at xxxxxxxxx>
>>> next(it)
'a'
>>> next(it)
'b'
>>> next(it)
'c'
>>> next(it)
Trackback (most recent call last):
  File "<stdin>", line 1, in ?
    next(it)
StopInteration
我们已经在迭代器协器后看到了这个机制,将迭代器的行为添加到你的类中是很容易的.定义一个方法该方法会返回一个带有__next__()方法的对象.如果这个类定义了__next__()方法,然后__iter__()仅仅能返回self：
----------------------------------------------------------
class Reverse:
  """Iterator for looping over a sequence backwards."""
  def __init__(self, data):
    self.data = data
    self.index = len(data)
  
  def __iter__(self):
    return self

  def __next__(self):
    if self.index == 0:
      raise StopInteration
    self.index = self.index - 1
    return self.data[self.index]
----------------------------------------------------------
>>> rev = Reverse('spam')
>>> iter(rev)
<__main__.Reverse object at XXXXXXXXX>
>>> for char in rev:
...   print(char)
...
m
a
p
s
----------------------------------------------------------

9.10.生成器
生成器对于创建迭代器是一个简单且强大的工具.他们是用正则函数写的但是无论什么时候想返回数据了,他们使用yield语句.每次next()函数被调用时,生成器会从它停止的地方重新恢复(它记得所有的数据值并且记得最后执行的是哪条语句).下面这个例子演示了如何简单的创建生成器:
----------------------------------------------------------
def reverse(data):
  for index in range(len(data)-1, -1, -1):
    yield data[index]
----------------------------------------------------------
>>> for char in reverse('golf'):
...   print(char)
...   
f
l
o
g
----------------------------------------------------------
**.迭代器每次只返回一个值，从上面例子可以看出来这一点，根据上面这个例子，reverse('golf')这个函数每次执行时它会记得上次是到哪了，这次该给啥了，这个具体的逻辑是生成器内部实现的，暂时先不考虑知道是这么回事即可，它对于要迭代一个很大值的时候或是类似情况会很有用，因为它不会一下子将所有情况都生成，而是一回只取一个，这样会省内存(最后一句我自己想的)
生成器能够做的所有事情,前面章节中描述的基于类的迭代器也可以做.使生成器如此紧凑是因为__iter__()方法和__next__()方法会被自动创建.

另一个主要的功能是本地的变量和执行语句在调用时会被自动保存.这使得函数更简单的被写并且比用使用像self.index和self.data这样的实例变量显示更清晰.

除了自动创建方法和保存程序状态外,当生成器结束时,他们会自动的抛出StopInteration异常.这些功能使得创建一个迭代器是容易的,与写正则函数相比省事不少.

9.11.生成器表达式
我们可以使用一个类似于列表推导的表达式来简洁的编码一个简单的生成器,与列表推导不同的是列表中使用的是方括号,而这里用的是圆括号.这些表达式是为生成器会立刻被enclosing函数使用的情形设计的.生成器表达式是比较紧凑的但是与完整的生成器定义相比缺乏通用性并且往往比相同功能的列表推导更容易记忆.
>>> sum(i*i for i in range(10))	  #平方和
285
>>> xvec = [10, 20, 30]
>>> yvec = [7, 5, 3]
>>> sum(x*y for x,y in zip(xvec, yvec))	  
260
>>> from math import pi, sin
>>> sine_table = {x: sin(x*pi/180) for x in range(0, 91)}
>>>unique_words = set(word for line in page for word in line.split())
>>>valedictorian = max((student.gpa, student.name) for student in graduates)
>>> data = 'golf'
>>> list(data[i] for i in range(len(data)-1, -1, -1))
['f', 'l', 'o', 'g']

注脚:除了一件事情.模块对象有一个密码的只读的属性称为__dict__,该属性会返回一个用于实现模块的名称空间的字典;名子__dict__是一个属性但不是一个全局名称.显然,使用它违反了名称空间实现的抽象,并且应该仅限在调试器中使用.
