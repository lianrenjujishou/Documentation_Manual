FIND(1)      General Commands Manual        FIND(1)

NAME
find-在上目录层级(directory hierarchy)中搜索文件

SYNOPSIS
find [-H] [-L] [-P] [-D debugopts] [-0level] [path...] [expression]

DESCRIPTION
该手册页记载的是GNU版本的find命令.GNU版的find查找目录树(还有一句修饰目录树的句子没翻译过来:rooted at each given file name)通过从左到右评估给定的表达式,依照优先级的规则(看OPERATORS部分),直到知道结果(对于操作数左手边是false,or是true),at which,find移动到下一个文件名.

如果你在一个对于安全来说非常重要的环境中使用find命令(例如,你正在搜索的目录对于其它用户来说是可写的),你应该读一下findutils文档的"Security Considerations"这一章,which被称为Finding Files and comes with findutils.与这页相比那篇文档包含更多详细的内容和讨论,因此你可能会在那篇文章中找到更多有用的信息资源.

OPTIONS
-H,-L和-P选项控制着对符号链接的处理.在命令行下这三个参数跟着是致力于对文件名或是目录名的检测,直到第一个参数是以'-'或'('或'!'开头.那个参数和任何跟着的参数被带到描述要搜索什么的表达式中.如果没给出路径,则使用当前目录作为搜索路径.如果没有任何要搜索的表达式,则使用-print参数(但是无论如何,你大概会考虑使用-print0参数代替).

该手册页讨论关于表达工列表中的'options'.这些options控制着find命令的行为,但是在最后的路径名后立即被指定.五个'real'的'options',-H,-L,-P,-D和-0必须出现在第一个路径名的前面,如果这种情况出现的话.双中横线--可以被用来表示任何剩余的参数,这些参数不是options(但确保所有以'./'或'/'开始的点通常都是更安全的,如果你在开始点的列表中使用了通配符的话).

-P
永远不要跟着符号链接.这是默认的行为.当find检查或是打印一个文件信息时,文件是一个符号链接,使用的信息应该来自于符号链接自身的属性.

-L
跟随符号链接.当find检查或是打印文件的信息时,使用的信息来自于符号链接所指向文件的属性,而不是来自符号链接本身的属性(除非符号链接是一个损坏的链接(指向的文件不存在?)或是find不能检查符号链接所指向的文件(没权限?)).这个选项的使用暗示包含一个-noleaf.如果稍后你使用-P选项,-noleaf一直是生效的.在查找期间,如果-L是有效的并且find发现了一个到子目录的符号链接,则被符号链接指向的这个子目录也会被搜索.

当-L参数是有效的,-type 断言(predicate谓语,述语)将会一直匹配符号链接所指向的文件的文件类型而不是链接本身的类型(除非链接是损坏的(所指向的文件不存在?)).使用-L会导致-lname和-ilname断言一直返回false.

-H 不跟随符号链接,除了当处理命令行参数的时候.当find检查或是打印文件信息时,使用的信息应该来自于符号链接本身的属性.对于这个行为来说唯一的异常是当在命令行指定的文件是一个符号链接文件,并且该链接可以被解析.对于那种情况,被使用的信息来自于该链接的指向(也就是说,链接是跟随的).链接自身的信息被用于回滚,如果符号链接所每向的文件不能被检测到的话.如果-H参数有效并且在命令行被指定的路径之一是一个指向目录的符号链接,那个目录的内容将会被检测(though(though在这里翻译为啥?)当然-maxdepth 0会阻止这个).

如果-H,-L和-P中超定超过一个,则每一个都会覆盖其它的;出现在命令行中的最后一个是起作用的.默认-P参数应该被考虑生效,除非-H或是-L被指定.

GNU版本的find在命令行自己处理的时候会频繁的统计文件(stat files),在任何搜索已经开始前.这些参数也影响着这些参数如何被处理.特别地,有大量的测试,这些测试会将列在命令行上的文件和我们当前考虑的文件做比较.在每一种情况中,在命令行中指定的文件都会被检测并且文件的某些属性会被保存.如果被命令的文件实际上是一个符号链接,并且-P参数是生效的(或者-H和-L都没有被指定),则用于比较的信息来自于符号链接(这里没写itself,但我感觉隐式的有)的属性.否则比较用的信息来自于符号链接所指向的文件.如果find不能跟随链接(例如,它(应该指的是当前登录的用户)没有足够的权限或是链接指向的文件不存在)则链接本身的属性会被使用.

当-H或-L选项是生效的,任何被列出作为-newer的参数的符号链接都会被间接引用(dereferenced(或译为弃用?解除参照?)),并且时间戳来自于符号链接所指向的文件.相同的考虑适用于-newerXY, -anewer和-cnewer.

-follow参数和-L参数的效果相似,但是-follow影响的是它出现的点(where it appears)(也就是说,-L不被使用但是-follow被使用,任何出现在命令行上-follow后面的符号链接都会被间接引用(dereference(或译为弃用?解除参照?)),出现在-follow之前的则不会).

-D debugoptions
打印诊断信息;这个参数于于诊断为什么find出来的东西不是你想要的会有帮助.debug选项的列表应该使用逗号隔开.debug选项没有被承诺在各发行版findutils之间相兼容.对于有效的debug选项的完整列表,可以参考'find -D help'的输出.有效的debug选项包括:

help 解释debugging选项

tree 使用原始格式和最佳格式来展示表达式树

stat 当文件被使用stat和lstat系统调用检查时打印信息.find程序尝试最小化这样的调用.

opt 打印有关最佳的表达式树的诊断信息;看-0选项.

rates 打印表示每个断言多长时间成功一次或是失败一次的总结

-0level
开启查询优化.当保存(保留)全部的影响时,find程序重新排序tests用来加速执行;也就是说,涉及到相互之间有副作用的断言不会被重新排序.优化级别如下:

0 等价于优化级别1

1
这是默认的优化级别并且符合于传统的行为.表达式被重新排序以便于仅仅基于文件名字的测试首先被执行(例如-name和-regex)

2 任何-type或是-xtype测试被执行,在任何基于文件名的测试之后,但是在任何需要来自索引节点信息的测试之前.在许多现代的UNIX版本中,文件类型通过readdir()返回,因此这些断言的评估速度要比首先需要统计文件断言的更快

3 在这个优化级别,全部基于开销的查询优化器都被开启.测试的排序被修改以便于便宜的测试(i.e.  fast)首先被执行,需要大开销的稍后执行,如果需要的话.在每一个开销带内,断言被更早的评估或者稍后根据他们是否成功.对于-o选项,可能成功的断言会较早的被评估,对于-a而言,可能会失败的断言过早的被评估.

基于开启的优化器有一个固定的主意对于任何给定的测试可能如何测试才会成功.在一些情况下,机率考虑到指定的测试特性(例如,-type f假设比-typc c更可能成功).基于开启的优化器当前被评估.如果它没有实际提高find的性能,它将会再次被移除.相反地,证明可靠性,强健性和有效性的优化可能在更低的优化级别开启,随着时间的过去(超时).然而,默认的行为(i.e.优化级别1)在4.3.x发行序列中不会被改变.findutils测试套件会运行所有的测试在每一个优化级别并且确保结果是相同的.

EXPRESSIONS
表达式由options(options影响所有的操作而不是指定文件的处理,并且总是返回true),tests(tests返回一个true值或是一个false值)和actions(actions有副作用并且返回一个true值或一个false值)组成,所有都被分隔符分隔.
-and被假设在这块操作符被忽略.

如果表达式除了-prune没有其它的actions了,则-print参数被执行在所有的文件上,对于这种情况(at which在这里翻译为啥?),表达式是true

OPTIONS
所有的options一直(总是)返回true.除了-daystart, -follow和-regextype外,其它选项影响所有的测试,包括在option之前指定的测试.这是因为当命令行被解析时选项被处理,当测试不做任何事情直到文件被检测.  -daystart, -follow和-regextype选项在这方面是不同的,他们仅仅对稍后出现在命令行上的测试起作用.因此,为了清晰起见,最好是将它们放到表达式的开始.如果你没有做这个(还是译为没有这样做?),一个警告会被发出.

-d -depth的同义词,是为了和FreeBAS,NetBSD,MacOS X和OpenBSD保持兼容

-daystart 测量(估量)时间(对于-amin, -atime, cmin, -ctime,
-mmin和-mtime来说)从今天的开始而不是从24小时之前.该选项仅仅影响后来出现在命令行的测试

-depth 处理目录本身以前的每个目录的内容. -delete action隐式的包含-depth.

-follow 被废用(或译为不赞成使用);使用-L参数替代.  间接引用(或译为弃用?解除参照?)的符号链接.隐式包含-nolef.  -follow选项仅仅影响命令行中出现在它后面的测试.除非-H或-L选项已经被指定,否则-follow选项的位置改变-newer断言的行为;任何被列在-newer参数中的文件都被间接引用(或译为弃用?解除参照?),如果它们是符号链接.相同的考虑适用于-neweerXY,-anewer和-cnewer.相似地,-type断言总是匹配符号链接指向的文件的类型而不是链接本身的类型.使用-follow会引起-lname和-ilname断言总是返回false.

-help, --help 打印find的命令行使用页的总结并退出.

-ignore_readdir_race
通常,find会发表一个错误消息当它统计一个文件失败时.如果你给出了这个选项并且一个文件被删除了在find命令从文件夹中读取文件名的时候和find尝试统计这个文件的时间之间,没有错误信息会发出.这也适用于名字被给出到命令行上的文件和文件夹.该选项起作用在命令行被读取的时候,这意味着在这个选项开启的时候你不能搜索这个文件系统的一部分并且在该选项关闭时也不能搜索它的一部分(which means that you cannot search one part of the filesystem with this option on and part of it with this option off)(如果你需要那样做,作为替代,你需要发出两条命令,一条是带有那个选项的,一条是没有那个选项的).  

-maxdepth levels 下降到最多的级别(一个非负整数)命令行参数下的目录级别.  -maxdepth 0意味着对命令行参数仅仅应用tests和actions.  

-mindepth levels 在小于levels的级别上不应用tests或actions(一个非负整数).
-mindepth 1 意味着除了命令行的参数外处理所有的文件.

-mount 在其它文件系统上不下降(descend)目录.还有一个替换名字-xdev,这个替换名字是为了和其它版本的find保持兼容性

-noignore_readdir_race 关闭-ignore_readdir_race的影响

-noleaf
不优化通过假设他们的子目录数比硬链接数少于2个的目录.该选项在搜索没有遵循Unix目录链接协议的文件系统时是需要的,例如CD-ROM或MS-DOS文件系统或者AFS卷挂载点.在一个普通的Unix文件系统上的每个目录都有至少两个硬链接:一个是文件名还有一个是'.'入口(条目).此外它的子目录(如果有的话)都有一个'..'入口来链接到该目录(简单点说就是子目录链接到父目录).当find正在检查一个文件夹的时候,在find统计该目录的子目录数比该目录的硬链接数少于2的时候,find就会知道该文件夹中剩下的条目都是非目录(在目录树中的'leaf'文件).如果仅仅是文件名需要被检测,则不需要统计它们;这会在搜索速度上有一个显著的提升.

-regextype type 改变正则表达式的语法被-regex和-iregex测试所理解,当稍后发生在命令行上.当前实现的类型是emacs(这是默认的),posix-awk,posix-basic, posic-egrep和posix-extended.  

-version, --version 打印find的版本号并退出.

-warn, -nowarn 打开或关闭警告信息.这些警告仅仅适用于命令行使用页,不是适用于find在搜索目录时遇到的任何条件.如果标准输入是一个tty的话,则默认的行为是根据-warn,否则的话是根据-nowarn.

-xdev 不在其它文件系统上下降目录

TESTS
某些tests,例如 -newerXY 和 -samfile, 允许当前检测到的文件和在命令行指定的文件之间做比较.当这些tests被使用时,引用文件的解释由-H,-L,-P和以前的-follow决定,但是引用文件仅仅在命令行被解析的时候检测(检查)一次.如果引用的文件不能被检测到(例如,stat(2)系统调用失败(for example, the stat(2) system call fails for it)),一条错误信息被发出,并且find命令带着一个非0的状态值退出 

数值参数可被指定为:

+n 大于n

-n 小于n

n 精确等于n

-amin n 文件最后一次访问时间是在n分钟前

-anewer file 文件最近最后被访问而不是文件被修改.如果文件是一个符号链接并且-H选项或者-L选项是有效的,符号链接指向的文件的访问时间被使用.(对于该选项目前的想法是:一.找出访 问时间比修改时间距离现在短的文件;二.系统能记录文件被修改的次数和被访问的次数,找出访问次数多于修改数次的文件)

-atime n 最后一次访问是在n天(n*24小时)前的文件.当find指出多少个24小时周期之前这个文件最后被访问时,任何的小数部分都被忽略,因此,为了匹配(比较) -atime+1,一个文件必须至少是在两天前被访问的. 

-cmin n 文件的状态最后被改变是在n分钟前

-cnewer file 文件的状态最后被修改的时间比文件最后被修改的时间距离现在更近.如果文件是一个符号链接并且-H选项或者-L选项是有效的,则使用符号链接指向的文件的status-change(改变状态)时间

-ctime n 文件的最后修改状态是在n*24小时(n天)之前.看对-atime的注释来理解舍入如何影响对文件状态的改变时间的解释

-empty 文件是空的并且是一个普通文件或是一个目录(即空的普通文件或是空目录)

-executable
匹配有可执行权限的文件(x)和可被搜索的目录(这个可被搜索指的是r还是x呢?我感觉应该是r,但是配合着前面的文件看又像是x)(在文件名解析检测).这个考虑到账户访问控制列表和其它的-perm测试忽略的权限artefacts.这个test利用(使用)access(2)系统调用,因此可以被做UID映射(或root-squashing)的NFS服务欺骗,因为许多系统在客户端的内核中实现access(2),因此不能利用保存在服务上的UID映射信息.因为这个test仅仅是基于access(2)系统调用的结果,没有许诺一个文件,对于这个文件test成功,可以实际被执行

-false 总是错误的

-fstype type 文件在一个文件系统类型为type的系统上.有效的文件系统类型在不同版本的Unix上是不同的(变化的);被某些Unix版本或是其它版本接受的一个不完整的文件系统列表是:ufs, 4.2,4.3,nfs,tmp, mfs, S51K, S52K.你可以使用带有%F的-printf指令来查看你的文件系统的类型

-gid n 文件的数值组ID是n

-group gname 文件属于组名(数值组ID也是允许的)

-ilname pattern 类似于-lname, 但是该匹配是大小写不敏感的.如果-L选项或是-follow选项是有效的,该test返回错误,除非符号链接是损坏的

-iname pattern 类似于-name， 但是该参数的匹配对大小写是不敏感的.例如,模式'fo*'和'F??'匹配文件名'Foo','F00','foo','f0o'等.在这些模式中,不像通过shell的文件名扩展,一个初始的'.'可以被'*'匹配.也就是说,find -name *bar会匹配文件'.foobar'.请注意你应该将模式括起来作为理所当然的事(as a matter of course),否则shell会在它们中扩展任何的通配符

-inum n 文件有索引节点号n.通常可以很容易的使用-samefile test来做替代

-ipath pattern 它的表现和-iwholename一样.该选项已经被废弃,因此请不要使用它

-iregex pattern 类似于-regex, 但是该匹配是大小写不敏感的

-iwholename pattern 类似于-wholename,但是该匹配是大小写不敏感的

-links n 文件有n个链接

-lname pattern 文件是一个符号链接它的内容匹配shell模式pattern.元字符'/'和'.'不被特殊对待.如果-L或-follow选项是有效的,该test返回false除非符号链接是损坏的

-mmin n 日期在n分钟之前被修改的文件 

-mtime n 日期在n*24小时之前被修改的文件.可以看一下atime的注释来理解rounding(舍入)如何影响文件修改时间的解释的

-name pattern 文件名的基本(基础)(带着被移除的目录打头的路径)匹配shell模式pattern.元字符('*','?'和'[]')匹配一个'.'在基础名(base name)的开头(在findutils-4.2.2中这是一个改变;看下面的STANDARDS CONFORMANCE部分).为了it下忽略一个目录和文件使用-prune;看-path的描述中的一个例子.大括号不被识别为特殊,尽管一些包含Bash的shells的这个事实imbue带有特殊意义的大括号在shell模式中.文件名匹配被执行带着fnmatch(3)库函数的使用.不要忘了使用引号关闭模式为了保护它免受shell的扩展.

-newer file 文件被修改的时间(距离现在)比file更近.如果file是一个符号链接并且-H选项或是-L选项是有效的,符号链接指向的文件的修改时间总是被使用的

-newerXY reference 用reference和当前文件的时间戳比较.reference参数通是一个文件的名字(它的时间戳之一被用来比较)但是它也可能是一个描述一个绝对时间的字符串.X和Y对于其它字母来说是占位符,并且这些字符选择哪个时间属于,reference是如何被用来比较

a 文件reference的访问时间
B 文件reference的出生时间(或叫创建时间)
c reference的索引节点状态改变时间
m 文件reference的修改时间
t reference被直接解释为一个时间

某些组合是无效的;例如,X为t时是无效的.某些组合不是被实现在所有的系统上;例如B不是被所有系统支持.如果一个无效的或是不被支持的XY组合被指定,一个致命的结果发生.时间说明被解释为关于GNU版本的-d选项的参数.如果你尝试使用一个reference文件的创建时间,出生时间不能被决定,一个致使的错误信息结果.如果你指定了一个涉及被检测文件的创建时间的test,这个test对任何文件都将会失败在这里创建时间是未知的.

-nogroup No group符合于文件的数字组ID

-nouser No user符合于文件的数字用户ID

-path pattern 文件名字匹配shell模式pattern.元字符不特别对待'/'或'.';因此,例如,  
            find . -path "./sr*sc"
该表达式将会打印被称为'./src/misc'的条目(如果当前文件夹下存在src/misc目录的话).为了忽略完整的路径扫描,使用-prune而不是检测树中的每一个文件.例如,为了跳过'src/emac'目录和该目录下所有的文件和目录,并且打印被发现的其它文件的名字,做一些事情像这个:
          find . -path ./src/emacs -prune -o -print
注意该模式匹配test适用于整个文件名,从在命令行指定的开始点之一开始.它将仅仅对于在这里使用一个完整路径名有意义如果相关的开始点也是一个完整路径.这意味着这个命令不会匹配任何事情:
             find bar -path /foo/bar/myfile -print
这个断言(predicate) -path也被HP-UX中的find支持并且-path将会在一个POSIX标准的即将来临的版本

-perm mode
文件的权限位精确地是mod(八进制或是符号).由于一个精确的匹配是必须的,如果你想为符号模式(symbolic modes)使用这个形式,你可能必须指定一个相当复杂的模式字符串.例如-perm g=w将会仅仅匹配拥有mode为0020的文件(也就是说,ones for which group write permission is the only permission set).你将想要使用'/'或'-'形式是更可能的,例如 -perm -g=w,将会匹配任何所在的组具有写权限的文件.可以看EXAMPLES部分来看说明的例子.

-perm -mode 文件的所有权限位mode都被设置.用这种形式,符号模式也是被接受的,并且这经常是这种方式,用这种方式将会想要使用它们.你必须指定'u','g'或'o'如果你使用一个符号模式.对于一些说明的例子看EXAMPLES部分

-perm /mode 文件的任何权限位mode被设置.在这种形式中符号模式是被接受的.你必须指定'u','g'或'o'如果你使用一个符号模式.对于一些说明的例子可以看EXAMPLES部分.如果在mode中没有权限位被设置,该test匹配任何的文件(这的想法和-perm -000的行为是始终如一的).

-perm +mode 被禁用的(被废弃的),和在mode中设置的任何权限位一起搜索文件的老方式.你应该使用-perm /mode代替.尝试使用带有符号模式的语法将会产生令人惊奇的结果.例如，'+u+x'是一个有效的符号模式(等价于+u,+x,例如0111)因此'+u+x'不会被评估为-perm +mode而是被替代作为精确的模式说明符-perm mode,因此它匹配带有精确的0111权限而不是带有任何可执行位设置的文件.如果你发现这个段落令人混乱的,你不是单独的-仅仅使用-perm /mode. 这个-perm test的形式被废弃了,因为POSIX说明符需要一个前导'+'的解释作为一个符号模式的部分,因此作为代替,我们切换到使用'/'.

-readable 匹配只读文件.这考虑到帐户访问控制列表和 -perm test忽略的其它权限人工制品.这个test使用access(2)系统调用,因此可能被NFS服务器欺骗,NFS服务器做UID映射(或是root-squashing),因为许多系统实现access(2)在客户端的内核,因此不能使用UID映射信息继续(held on)服务器

-regex pattern 文件名匹配正则表达式pattern.这是一个在全路径上的匹配,不是一个搜索.例如,为了匹配一个名为'./fubar3'的文件你可以使用正则表达式'.*bar.'或是'.*b.*3',但不能用'f.*r3'.被find理解的正则表达式默认使用的是Emacs正则表达式,但是可以使用-regextype选项来改变默认使用的正则表达式

-samefile name 将那些有相同索引节点name的文件搜索出来.当-L是有效的,这可以包括符号链接.

-size n[cwbkMG] 文件使用n个单位的空间.下面的后缀可以被使用:
    'b' 适合于512字节块(如果没有后缀被使用该选项是默认的)
    'c' 适合于字节
    'w' 适合于2个字节的字
    'k' 适合于Kilobytes(1024字节的单位)
    'M' 适合于Megabytes(1048576字节的单位)
    'G' 适合于Gigabytes(1073741824字节的单位)

该size不计算间接的块,但是它计算实际上不被分配的稀疏文件(sparse files).牢记-printf的'%k'和'%b'格式说明符处理稀疏文件不同.'b'后缀一直表示512字节块并且从来不表示1Kilobyte块,这和-ls的行为是不同的.

-true 总是正确的

-type c 文件的类型是c:
    b 特殊块(缓冲的)
    c 特殊字符(非缓冲的)
    d 目录
    p 指定的管道(FIFO)
    f 普通文件
    l 符号链接;如果-L选项或是-follow选项是有效的则这从来都不是正确的,除非符号链接是损坏的.如果你想要搜索符号链接当-L是有效的,使用-xtype.
    s 套接字
    D 通道(door)(Solaris)

-uid n 文件的数字用户ID是n

-used n 文件持续被访问n天在文件的状态被后被修改后(File was last accessed n days after its status was last changed)

-user uname 文件被用户uname拥有(数字形式的用户ID也是允许的)

-wholename pattern 参考-path. 可选的这比-path有更少的可移植性(更小的便携性?)

-writable 匹配具有可写权限的文件.这考虑到帐户访问控制列表和 -perm test忽略的其它权限人工制品.这个test使用access(2)系统调用,因此可能被NFS服务器欺骗,NFS服务器做UID映射(或是root-squashing),因为许多系统实现access(2)在客户端的内核,因此不能使用UID映射信息继续(held on)服务器

-xtype c 与-type一致,除非文件是一个符号链接.对于符号链接来说:如果-H或-P选项被指定,如果文件是一个指向类型是c的文件的链接,是正确的;如果-L选项已经被给出,如果c是'l'是正确的.换句话说,对于符号链接,-xtype检查-type不检测的文件类型

ACTIONS
-delete 删除文件;是正确的如果移除成功.如果移除失败,一个错误信息会发出.如果-delete失败,find的退出状态将会是一个非零数(当find最后退出时).-delete的使用会自动打开-depth选项 

警告:不要忘记find命令行被评估为一个表达式,因此把-delete放到第一位会使find尝试上删除你指定的开始点下的所有文件.当testing一个稍后打算和-delete一起使用的find命令行,你应该明确的指定-depth为了避免之后的吃惊.因为-delete暗含-depth,你不能有效地一起使用-prune和-delete

-exec command ; 执行command;是正确的如果0状态被返回.所有下列对于find的参数被带到命令行中的参数,直到一个由';'组成的参数被遇到.字符串'{}'被替换通过当前被处理的文件名.无论什么地方它发生在参数中对于command,不仅仅在参数中,在这里它是独立的,像在find的某些版本中.这里结构可能都需要被转义(和一个'\')或者被引起来为了保护它们免受shell扩展的影响.对于-exec选项使用的例子可以看EXAMPLES部分.对于每个被匹配到的文件指定的command被执行一次.command被执行在开始目录中.有不可避免的安全问题围绕着-exec 动作(action)的使用;你应该使用-execdir选项代替.

-exec command {} + 这个-exec动作的变体在被选择的文件上运行指定的command,但是命令行被建立通过在结尾追加每个被选择的文件名;命令的调用总数将会小于被匹配(还是译为被匹配到的?)的文件.命令行被建立用和xargs建立它的命令行非常相同的方式.在命令行中,仅仅'{}'的一个实例被允许.该command被执行在开始目录.

-execdir command ; 如同-exec,但是指定的命令被运行是从包含被匹配上的文件的子目录开始,这里的子目录通常不是find开始寻找文件的目录.对于调用命令这是一个更加安全的方法,由于它避免了竞争条件在对匹配上的文件路径做解析期间.正如-exec 动作(action),-execdir的'+'形式将会建立一个命令行来处理超过一个被匹配上的文件,但是任何被给出的命令调用将仅仅列出存在相同子文件夹中的文件.如果你使用这个选项,你必须确保你的$PATH环境变量不会引用'.';否则一个攻击者可以运行任何他们喜欢的命令通过在一个你将会运行-execdir的文件中leaving一个appropriately-named文件.这同样适用于在$PATH中有条目,是空的或不是绝对的目录名的情况.

-fls file True;如同-ls但是写到file,如同-fprint.输出文件一直被创建,即使断言(predicate)从来没有被匹配.关于在文件名中的字符是如何被处理的信息可以看UNUSUAL FILENAMES部分

-fprint file True;将完整的路径名打印到文件file中.当find被运行时,如果file不存在,则会创建一个file;如果file存在,则会被截短(truncated).文件名"/dev/stdout"和"/dev/stderr"被特殊处理;它们分别指的是标准输出和标准错误输出.输出文件总是被创建,即使断言(predicate)从来没有被匹配上.关于文件名中不寻常的字符如何被处理的信息,参考UNUSUAL FILENAMES部分

-fprint0 file True;如同-print0但是如同-fprint一样会写入file.输出文件总是被创建,即使断言(predicate)从来没有被匹配上.关于文件名中不寻常的字符如何被处理的信息可以参考UNUSUAL FILENAMES部分

-fprintf file format True;如同-printf但是如同-fprint会写入file.输出文件总是被创建,即使断言(predicate)从来没有被匹配.关于文件名中的不寻常字符如何被处理的信息可以参考UNUSUAL FILENAME部分

-ls True;在标准输出里用ls -dils的格式列出当前的文件.块计数具有1K块的性质,除非环境变量POSIXLY_CORRECT被设置,在这种情况下512-byte块被使用.关于文件名中的不寻常字符如何被处理的信息可以参考UNUSUAL FILENAMES部分

-ok command ; 如同-exec但是首先问一下用户.如果用户同意,运行这个命令.否则仅仅返回false.如果命令被运行,它的标准输入被从/dev/null重定向.

对提示符的响应是匹配一对正则表达式来决定是否它是一个肯定的或是否定的响应.这个正则表达式被从系统获取,如果'POSIXLY_CORRECT'环境变量被设置,或者从find的消息翻译获取.如果系统没有合适的定义,find的自己的定义将会被使用.另一种情况,正则表达式自己的解释将会被环境变量'LC_CTYPE'(字符集)和'LC_COLLATE'(字符范围和等值的集合)影响

-okdir command ; 如同-execdir但是和-ok用相同的方式首先会问一下用户.如果用户不同意,仅仅返回false.如果命令被运行,它的标准输入被从/dev/null重新定向.

-print True;在标准的输入打印完整的文件名,被一个新行跟随.如果你正将find的输出通过管道作为另一个程序的输入并且你正在搜索的文件可能包含一个新行可能性是很小的,然后你应该认真地考虑使用-print0选项来代替-print.有关文件中不寻常的字符如何被处理的信息可以参考UNUSUAL FILENAME.

-print0 True;将文件的全名打印在标准输出,被一个空字符跟随(代替-print使用的新行字符).这个允许包含新行或是其它类型的可以被处理find输出的程序正确解释的空白的文件名.这个选项相当于xargs的-0选项.

-printf format True;在标准输出打印format,解释'\'转义和'%'指令.域宽(或说字段宽度fields widths)和精度可以被指定与'printf' C函数一样.请注意,许多的字段(fields)被作为%s打印而不是%d,这可能意味着标记(flags)不按你期望的工作.这也意味着'-'标记不工作(它强制着字段左对齐).不像-print, -printf不会在字符串的结尾添加一个新行.转义(escapes)和指令(directives)是:

\a 报警铃
\b 退格
\c 立刻停止从该格式输出并且清除输出
\f 换页
\n 新行
\r 回车
\t 水平制表符
\v 垂直制表符
\0 ASCII NUL
\\ 字面意思的反斜杠('\')
\NNN ASCII码是NNN(八进制)的字符
一个'\'字符后跟着其它字符(这里的其它字符应该是和上面介绍的这些特别字符对着说的,意思是除上面介绍的这些字符之外的字符)被对待作为一个普通字符,因此它们都被打印
%% 一个字面意思的百分比符号
%a 被C的'ctime'函数返回的用format格式表示的文件的最后访问时间
%Ak 使用通过k指定的格式表示文件的最后访问时间,C的'strftime'函数或者是'@'或者是一个指令.对于k可能的值被列在下面;它们里面的一些可能不是对所有系统都有效,由于不同系统对待'strftime'不同.
    @ 自从Jan. 1, 1970, 00:00 GMT,带有小数部分到现在的秒数
    时间字段:
    H 小时(00..23)
    I 小时(01..12)
    k 小时( 0..23)
    l 小时( 1..12)
    M 分钟(00..59)
    p 区域设置的AM或PM
    r 时间, 12-小时 (hh:mm:ss [AP]M)
    S 秒 (00.00 .. 61.00). 有一个小数部分
    T 时间, 24-小时 (hh:mm:ss)
    + 日期和时间,通过'+'分隔,例如'2004-04-28+22:22:05.0'.这是一个GNU扩展.该时间在当前的时区被给出(当前的时区可能会被TZ环境变量的设置而受影响).秒字段包含一个小数部分 
    X 区域设置的时间表示 (H:M:S)
    Z 时区(例如,EDT),如果没有时区是可决定的则什么也没有
    日期字段:
    a 区域设置的缩略工作日名称(Sun..Sat)
    A 区域设置的工作日全名,可变长度(Sunday..Saturday)
    b 区域设置的月份缩写名称(Jan..Dec)
    B 区域设置的月份全称,可变长度(January..December)
    c 区域设置的日期和时间(Sat Nov 04 12:02:33 EST
    1989).这个格式和ctime(3)是相同的因此为了保持和那个格式(这里的那个格式是指ctime(3)?)的兼容性,在秒字段没有小数部分.
    d 月份的天数(01..31)
    D 日期(mm/dd/yy)
    h 和b相同
    j 年份的天数(001..366)
    m 月份(01..12)
    U 以周六作为每周第一天的一年里的星期数(00..53)
    w 星期的天(0..6)
    W 以周一作为每周第一天的一年里的星期数(00..53)
    x 区域设置的日期表示(mm/dd/yy)
    y 年份的最后两位数(00..99)
    Y 年份(1970...)

%b 用512-byte块表示被用于该文件的磁盘空间的数量.因为磁盘空间被分配用文件系统块大小的倍数,这经常会大于%s/512,但是磁盘空间可能也会小于%s/512,如果文件是一个稀疏文件.
%c 用format表示由C中'ctime'函数返回的文件的最后状态被改变的时间
%Ck 用k指定的格式显示文件的最后状态修改时间,(...)与%A一致
%d 在目录树中文件的深度;0表示该文件是一个命令行参数
%D 设备号,在这个设备上文件存在(st_dev字段的结构统计(状态?)),用十进制表示
%f 带有被移除的前置目录的文件名字(仅仅最后的元素)
%F 文件所在的文件系统的类型;这个值可以用于-fstype
%g 文件的组名,或者如果没有组名也可以是数字形式的组ID
%G 文件数字形式的组ID
%h 文件名字的前置目录(所有的除了最后的元素).如果文件名不包含斜杠(因为它是在当前目录)则%h说明符扩大到'.'.
%H 命令行参数,参这个参数下文件被发现
%i 文件的索引节点号(用十进制表示)
%k 被用于该文件的磁盘空间数量用1k的块作为单位.因为磁盘空间被分配为文件系统块大小的倍数,这通常要大于%s/1024,但是也可能小于%s/1024,如果文件是一个稀疏文件
%l 符号链接的对象(如果文件不是一个符号链接则是空字符串)
%m
文件的权限位(用八进制表示).该选项使用'传统'数字,大多数的Unix系统实现都是使用'传统'数字,但是如果你的特别的实现使用一个八进制权限位的不寻常排序,你将会看到文件模式的实际值与%m的输出之间的不同.通常你想要有一个前导的0在这个数上,并且为了做这个,你应该使用#标记(flag)(例如,'%#m').
%M 文件的权限(用符号的形式,就像(as for)ls).这个指令支持4.2.5及以后版本的findutils
%n 到文件的硬链接号
%p 文件的名字
%P 带有命令行参数名的文件名字,under which(这里是指命令行参数名还是指文件名?)它被发现移除了
%s 用bytes表示文件的大小
%S 文件的稀疏.这被计算作为(BLOCKSIZE*st_blocks /
st_size).对于一个具有确定长度的普通文件,你将会得到的精确值依赖于你所用的系统(也就是说不同的系统得到的值不同,这就是所谓的依赖系统).然而,通常稀疏文件有小于1.0的值,并且使用间接块的文件可能有大于1.0的值.被用于BLOCKSIZE的值是系统依赖的,但通常是512bytes.如果文件大小是0,被打印的值是未定义的.对于st_blocks,在缺乏支持的系统上,一个文件的稀疏被假定为1.0.
%t 用format表示由C中'ctime'函数返回的文件的最后修改时间 
%Tk 用format表示由k指定的文件的最后修改时间,(..)与'%A'的行为一致
%u 文件的用户名,如果用户没有名字则是数字形式的用户ID
%U 文件数字形式的用户ID
%y 文件的类型(如同ls中的-l参数ls -l),U=unknown类型(不应该发生)
%Y 文件的类型(如同%y),加上下列的(跟随的)符号链接: L=loop, N=nonexistent

一个被跟着其它字符(这里的其它字符指的是上面没有提到过的?)的'%'是被废弃的,但是其它字符被打印(不要依靠这个,将来的格式可能会被介绍(引进?)).在format参数的结尾有一个'%'会导致未被定义的行为,因为没有跟着的字符.在某些区域设置中,它可能会隐藏你的通道关键字(door keys),当in others,它可能会从你正在读的小说中移除最后页

%m和%d指令支持#,0和+标记,但是其它指令不支持,即使它们打印数字.不支持这些标记的数字指令包括G,U,b,D,k和n.'-'格式标记被支持并且改变了一个字段的对齐从右对齐(默认的对齐方式)到左对齐

关于文件名中的不寻常字符如何被处理可以参考UNUSUAL FILENAMES部分

-prune Ture;如果文件是一个目录,则不descend into(翻译是下降进,通俗讲应该就是说不一层一层的进子目录了,我感觉是这样)它.如果-depth被给出,false;没有影响(效果?作用?).因为-delete隐含着有-depth选项,你不能有效地一起使用-prune和-delete

-quit 立即退出.没有子进程会留下来继续运行,但是没有更多的在命令行指定的路径被处理.例如,find /tmp/foo /tmp/bar -print -quit将仅仅会打印/tmp/foo.任何已经使用-execdir ... {} +组合的命令行将会在find退出之前被调用.退出状态可能为0也可能不为0,依靠是否一个错误已经发生

UNUSUAL FILENAMES
许多的find actions导致在其它用户控制下的数据打印.这包括文件名,大小,修改时间等等.文件名是一个潜在的问题,因为它们能包含除'\0'和'/'之外的任何字符.在文件名中的不寻常字符可以做意外的和不可取的事情对(到?)你的终端(例如,在一些终端上改变你的函数关键字的设置).不寻常字符被做不同的处理通过变化的actions,正如下面描述的.

-print0, -fprint0 总是打印精确的文件名,未被改变的,即使是打算输出到一个终端.

-ls, -fls 不寻常字符总是被转义.空白,反斜杠,和大引号字符被使用C-style转义打印(例如'\f','\"').其它的不寻常字符被打印使用一个八进制转义.其它可打印的字符(对于-ls和-fls这些是八进制041到0176之间的字符)被按原样(as-is)打印

-printf, -fprintf 如果打算输出到终端,它会被原样打印.否则结果依赖于你正在使用的指令.指令%D,%F,%g,%G,%H,%Y和%y扩展到没有在文件拥有者控制下的值,因此被原样打印.指令%a,%b,%c,%d,%i,%k,%m,%M,%n,%s,%t,%u和%U有在文件拥有者控制下的值,但是which不能被使于发送任意数据到终端,因此这些被原来打印.指令%f,%h,%l,%p和%P被引起来.这个引用被执行和GNU版本的ls是相同的.这不是相同的被引起来的机制,as the one(依照这一个)被用于-ls和-fls.如果你能决定要使用什么format对于find的输出,然后,通常使用'\0'作为一个终结符是更好的比使用新行,由于文件名可以包含空格(空白?)和新行字符.'LC_CTYPE'环境变量的设置被用于决定哪个字符需要被引起来.

-print, fprint 引号(引用?)被处理用和-printf和fprintf相同的方式.如果你正在一个脚本中使用find或者在一个被匹配的文件可能有任意的名字的位置 你应该考虑使用-print0代替-print.

-ok和-okdir actions原样打印当前的文件名.将来的发行版可能会改变这个行为.

OPERATORS
用优先级递减的顺序列出:
( expr ) 强制优先.因为圆括号对于shell来说是特殊的,通常你需要将它们引起来(但是看到段尾的那个例子感觉翻译为引起来不大合适,quote在这里是不是翻译为转义更好理解呢,还是之前看的东西就看错了).在该手册页许多的例子使用反斜杠是为了这个目的: '\(...\)'代替'(...)'.
! expr 正确的如果expr是false.这个字符通常需要保护shell的解释.
-not expr 和! expr是一样的,但是非POSIX适用(适合?兼容?)
expr1 expr2 一行里的两个表达式被拿来组合带有一个隐式的"and";expr2不被评估如果expr1是false
expr1 -a expr2 等同于expr1 expr2
expr1 -and expr2 等同于expr1 expr2,但是非POSIX适合(适用?兼容?)
expr1 -o expr2 0r;expr2不被评估如果expr1是正确的
expr1 -or expr2 等同于expr1 -o expr2,但是非POPSIX适合(适用?兼容?)
expr1 , expr2 列表;expr1和expr2都总是被评估.expr1的值被废弃了;列表的值就是exxpr2的值.逗号分隔符对于搜索几个不同类型的事情是有用的,但是遍历文件系统层级仅一次.-fprintf action可以被用来列出不同被匹配的条目到几个不同的输出文件.

STANDARDS CONFORMANCE
对POSIX 标准最接近的适合(适应?兼容?),你应该设置POSIXLY_CORRECT环境变量.下面的选项是在POSIX标准中被指定的(IEEE Std 1003.1, 2003 Edition):
-H 该选项是被支持的
-L 该选项是被支持的
-name 该选项是被支持的,但是POSIX一致性依赖于系统的fnmatch(3)库函数的POSIX一致性.自findutils-4.2.2起,shell元字符(例如'*','?'或'[]')会匹配一个前导的'.',因为IEEE PASC解释 126需要这个.这是一个来自findutils之前版本的改变
-type 被支持的.POSIX指定'b','c','d','l','p','f'和's'.GNU版本的find也支持'D',表示一个通道,在这里OS提供这些
-ok 被支持的.响应的解释是根据"yes"和"no"模式,被选择通过设置'LC_MESSAGES'环境变量.当'POSIXLY_CORRECT'环境变量被设置,这些模式采用一个正的(yes)或负的(no)响应系统的定义.对于nl_langinfo(3)可以看系统的文档,尤其是YESEXPR和NOEXPR.  当'POSIXLY_CORRECT'没有被设置,模式采用find自己的信息目录代替
-newer 被支持的.如果被指定的文件是一个符号链接,它一直被废弃.这是一个来自之前行为的改变,它用来从符号链接拿到相关的时间;看下面HISTORY部分
-perm 被支持的.如果POSIXLY_CORRECT环境变量没有被设置,某些在POSIX中无效的模式参数为了(例如 +a+x)反向兼容性也是被支持的

其它的断言(predicates):
    断言(predicates) -atime, -ctime, -depth, -group, -links, mtime, -nogroup, -nouser, -print, -prune, -size, -user和-xdev是全部被支持的

POSIX标准 指定圆括号'(',')',否定的'!'和'and'和'or'操作符(-a, -o).

其它所有的选项,断言(predicates),表达式等等都是在POSIX标准上的扩展.然而,这里面许多的扩展都不是唯一的对于GNU版的find来说.

POSIX标准需要find 检测回环(循环?):
    find工具会检测无限的循环(回环);也就是说,键入一个之前被放问过的目录,这个目录是一个最后遇到文件的始社(祖先?上代?).当它检测到一个无限的循环,find会写一个诊断信息到标准的错误并且或者会恢复它在层级中的位置或者会结束它

GNU版本的find遵守这些要求.包含是硬链接到一个祖先的条目的目录的链接数经常低于他们应该是.这个意味着GNU版本的find有时优化一个子目录的访问,这个目录实际上是一个到源始(ancestor)的链接。因为find实际上不键入如此的一个子目录,避免发出一个诊断信息是被允许的.尽管这个行为可能有点混淆,任何人实际上依靠这个行为是不太可能的.如果leaf优化已经用-noleaf被关闭了,这个目录的条目(入口?)会一直被检测并且诊断信息会被发出,在这里它是适合的.符号链接不能同样地用于创建文件系统循环,但是如果-L选项或是-follow选项在使用,一个诊断信息被发出当find遇到一个号链接的循环时.正如包含硬链接的循环一样,leaf优化经常意味着find了解它不需要调用stat()或是chdir()在符号链接上,因此这个诊断不是频繁需要的.

-d选项被支持对于多种BSD系统的兼容,但是你应该使用兼容POSIX的选项-depth来代替

POSIXLY_CORRECT环境变量不影响-regex或是-iregex 测试的行为,因为这些测试没有指定在PPOSIX标准里

ENVIRONMENT VARIABLES
LANG 为被重设或是空的国际化变量提供一个默认值
LC_ALL 如果设置一个非空的字符串值,重写所有其它国际化变量的值
LC_COLLATE
POSIX标准指定这个变量影响被用于-name选项的模式匹配.GNU版本的find使用fnmatch(3)库函数.因此对'LC_COLLATE'的支持依赖于系统库.这个变量也影响对-ok响应的解释;当'LC_MESSAGES'变量选择用于解释对-ok响应的实际模式,在模式中的任何方括号表达式的解释将会被'LC_COLLATE'影响.
LC_CTYPE 这个变量影响用于正则表达式的字符集的处置并且也伴随着-name测试,如果系统的fnmatch(3)库函数支持这个.这个变量也影响用于解释-ok选项发布在正则表达式中的任何字符集的解释.'LC_CTYPE'环境变量也会影响哪个字符会被考虑作为非打印的当文件名被打印时;看UNUSUAL FILENAMES部分
LC_MESSAGES 决定被用于国际化信息的区域设置.如果'POSIXLY_CORRECT'环境变量被设置,这也决定响应到由-ok action制造的提示符
NLSPATH 决定国际化信息目录的位置
PATH 影响被搜索的目录为了找到可执行的被-exec, -execdir, -ok和-okdir所调用的
POSIXLY_CORRECT 决定被用于-ls和-fls的块大小.如果POSIXLY_CORRECT被设置,块采用512字节作为单位.否则他们用1024字节作为单位.

设置这个变量默认也会关闭警告信息(也就是说,隐式的有个-nowarn),因为POSIX需要除去-ok输出,所有被打印到标准错误的信息被诊断并且一定导致一个非0的退出状态

当POSIXLY_CORRECT没被设置,-perm +zzz仅被对待像-perm
/zzz,如果+zzz不是一个有效的符号模式.当POSIXLY_CORRECT被设置,如此的构建会被作为一个错误对待.

当POSIXLY_CORRECT被设置,由-ok选项制作的到提示符的响应被解释根据系统的信息目录,根据find的自己的信息转换正相反

TZ 影响时区,用于某些和时间有关的-printf和-fprintf的格式指令

EXAMPLES

find /tmp -name core -type f -print | xargs /bin/rm -f
在/tmp目录中或是/tmp里更深层的目录中查找名为core的文件并且将它们删除.注意,如果有文件名包含新行,单个或是多个引号,或是空格则这个语句会错误的工作.(这里最后一句的文件名指的是已经找到的文件还是搜索的目录中含有那些条件的文件?)

find /tmp -name core -type f -print0 | xargs -0 /bin/rm -f
